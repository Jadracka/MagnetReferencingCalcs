
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>functions &#8212; Magnet Referencing Calculations Documentation 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for functions</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions.</span>

<span class="sd">Functions for Magnet Referencing Code.</span>

<span class="sd">Author: Jana Barker</span>
<span class="sd">Date: Created on Fri Jul 28 13:54:12 2023</span>

<span class="sd">Description:</span>
<span class="sd">------------</span>
<span class="sd">This is a file containing all functions necessary in orther to fit circles into</span>
<span class="sd">measured 3D or 2D points.</span>
<span class="sd">This file also contains functions to read in a Spatial Analyzer output file</span>
<span class="sd">and pars it into needed dictionaries.</span>

<span class="sd">Note:</span>
<span class="sd">----</span>
<span class="sd">- made together with ChatGPT, but tested by human.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">least_squares</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
<span class="c1"># from mpl_toolkits.mplot3d import Axes3D</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>


<div class="viewcode-block" id="gon_to_radians"><a class="viewcode-back" href="../functions.html#functions.gon_to_radians">[docs]</a><span class="k">def</span> <span class="nf">gon_to_radians</span><span class="p">(</span><span class="n">gon</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert an angle in gradians (gons) to radians.</span>

<span class="sd">    This function takes an angle in gradians and returns its equivalent</span>
<span class="sd">    angle in radians.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gon (float): Angle in gradians (gons) to be converted to radians.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float: Angle in radians equivalent to the input angle in gradians.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; gon_to_radians(200)</span>
<span class="sd">    3.141592653589793</span>
<span class="sd">    &gt;&gt;&gt; gon_to_radians(100)</span>
<span class="sd">    1.5707963267948966</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">gon</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">400</span><span class="p">)</span></div>


<div class="viewcode-block" id="degrees_to_radians"><a class="viewcode-back" href="../functions.html#functions.degrees_to_radians">[docs]</a><span class="k">def</span> <span class="nf">degrees_to_radians</span><span class="p">(</span><span class="n">degrees</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert an angle in degrees to radians.</span>

<span class="sd">    This function takes an angle in degrees and returns its equivalent</span>
<span class="sd">    angle in radians.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    degrees (float): Angle in degrees to be converted to radians.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float: Angle in radians equivalent to the input angle in degrees.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; degrees_to_radians(180)</span>
<span class="sd">    3.141592653589793</span>
<span class="sd">    &gt;&gt;&gt; degrees_to_radians(90)</span>
<span class="sd">    1.5707963267948966</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">degrees</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">)</span></div>


<div class="viewcode-block" id="cartesian_to_spherical"><a class="viewcode-back" href="../functions.html#functions.cartesian_to_spherical">[docs]</a><span class="k">def</span> <span class="nf">cartesian_to_spherical</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Cartesian coordinates to spherical coordinates.</span>

<span class="sd">    Converts the given Cartesian coordinates (x, y, z) to spherical coordinates</span>
<span class="sd">    (r, theta, phi).</span>
<span class="sd">    r represents the radial distance from the origin to the point.</span>
<span class="sd">    theta represents the inclination angle measured from the positive z-axis.</span>
<span class="sd">    phi represents the azimuthal angle measured from the positive x-axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x (float): x-coordinate in Cartesian space.</span>
<span class="sd">    y (float): y-coordinate in Cartesian space.</span>
<span class="sd">    z (float): z-coordinate in Cartesian space.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple: A tuple containing (r, theta, phi) in spherical coordinates.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; cartesian_to_spherical(1, 1, 1)</span>
<span class="sd">    (1.7320508075688772, 0.9553166181245093, 0.7853981633974483)</span>
<span class="sd">    &gt;&gt;&gt; cartesian_to_spherical(0, 0, 2)</span>
<span class="sd">    (2.0, 1.5707963267948966, 0.0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">z</span> <span class="o">/</span> <span class="n">r</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span></div>


<div class="viewcode-block" id="spherical_to_cartesian"><a class="viewcode-back" href="../functions.html#functions.spherical_to_cartesian">[docs]</a><span class="k">def</span> <span class="nf">spherical_to_cartesian</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Hz</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert spherical coordinates to 3D Cartesian coordinates.</span>

<span class="sd">    Converts the given spherical coordinates (d, Hz, V) to 3D Cartesian</span>
<span class="sd">    coordinates (X, Y, Z).</span>
<span class="sd">    d represents the radial distance from the origin to the point.</span>
<span class="sd">    Hz represents the horizontal angle measured from the positive x-axis.</span>
<span class="sd">    V represents the zenithal angle measured from the positive z-axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d (float): Radial distance in spherical coordinates.</span>
<span class="sd">    Hz (float): Horizontal angle in radians.</span>
<span class="sd">    V (float): Zenithal angle in radians.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple: A tuple containing (X, Y, Z) in 3D Cartesian coordinates.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; spherical_to_cartesian(1.0, 0.7853981633974483, 0.7853981633974483)</span>
<span class="sd">    (0.5000000000000001, 0.5000000000000001, 0.49999999999999994)</span>
<span class="sd">    &gt;&gt;&gt; spherical_to_cartesian(2.0, 1.5707963267948966, 0.0)</span>
<span class="sd">    (1.2246467991473532e-16, 2.0, 0.0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">Hz</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">Hz</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span></div>


<div class="viewcode-block" id="spherical_to_cartesian_unit"><a class="viewcode-back" href="../functions.html#functions.spherical_to_cartesian_unit">[docs]</a><span class="k">def</span> <span class="nf">spherical_to_cartesian_unit</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d_unit</span><span class="p">,</span> <span class="n">angle_unit</span><span class="p">,</span> <span class="n">Hz</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Spherical to Cartesian coordinates with specified units.</span>

<span class="sd">    Converts the given spherical coordinates (d, Hz, V) to 3D Cartesian</span>
<span class="sd">    coordinates (x, y, z) in the specified units.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d (float): Radial distance in spherical coordinates.</span>
<span class="sd">    angle_unit (str): Unit of the angles. Choose from &#39;rad&#39;, &#39;gon&#39;, or &#39;deg&#39;.</span>
<span class="sd">    Hz (float): Horizontal angle.</span>
<span class="sd">    V (float): Zenithal angle.</span>
<span class="sd">    d_unit (str): Unit of the radial distance.</span>
<span class="sd">        Choose from &#39;um&#39;, &#39;mm&#39;, &#39;cm&#39;, or &#39;m&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple: A tuple containing (x, y, z) Cartesian coordinates in the specified</span>
<span class="sd">    units.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError: If an invalid angle unit or radial distance unit is specified.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; spherical_to_cartesian_unit(1.0, &#39;rad&#39;, 0.7853981633974483,</span>
<span class="sd">                                    0.7853981633974483, &#39;mm&#39;)</span>
<span class="sd">    (0.5000000000000001, 0.5000000000000001, 0.49999999999999994)</span>
<span class="sd">    &gt;&gt;&gt; spherical_to_cartesian_unit(2.0, &#39;deg&#39;, 90, 0.0, &#39;cm&#39;)</span>
<span class="sd">    (1.2246467991473532e-16, 200.0, 0.0, &#39;mm&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert the angle to radians if needed</span>
    <span class="k">if</span> <span class="n">angle_unit</span> <span class="o">==</span> <span class="s1">&#39;gon&#39;</span><span class="p">:</span>
        <span class="n">Hz</span> <span class="o">=</span> <span class="n">gon_to_radians</span><span class="p">(</span><span class="n">Hz</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">gon_to_radians</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">angle_unit</span> <span class="o">==</span> <span class="s1">&#39;deg&#39;</span><span class="p">:</span>
        <span class="n">Hz</span> <span class="o">=</span> <span class="n">degrees_to_radians</span><span class="p">(</span><span class="n">Hz</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">degrees_to_radians</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="c1"># Convert d to millimeters</span>
    <span class="k">if</span> <span class="n">d_unit</span> <span class="o">==</span> <span class="s1">&#39;um&#39;</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">*=</span> <span class="mf">0.001</span>
    <span class="k">elif</span> <span class="n">d_unit</span> <span class="o">==</span> <span class="s1">&#39;mm&#39;</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">*=</span> <span class="mf">1.0</span>
    <span class="k">elif</span> <span class="n">d_unit</span> <span class="o">==</span> <span class="s1">&#39;cm&#39;</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">*=</span> <span class="mf">10.0</span>
    <span class="k">elif</span> <span class="n">d_unit</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">*=</span> <span class="mf">1000.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid d unit specified.&quot;</span><span class="p">)</span>

    <span class="c1"># Calculate Cartesian coordinates in millimeters</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">Hz</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">Hz</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="s1">&#39;mm&#39;</span></div>


<div class="viewcode-block" id="get_variable_name"><a class="viewcode-back" href="../functions.html#functions.get_variable_name">[docs]</a><span class="k">def</span> <span class="nf">get_variable_name</span><span class="p">(</span><span class="n">variable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the name of a variable.</span>

<span class="sd">    This function takes a variable and returns its name as a string. It does</span>
<span class="sd">    so by examining the calling frame&#39;s locals and globals dictionaries.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    variable : any</span>
<span class="sd">        The variable for which the name is to be retrieved.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        The name of the given variable as a string.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Example usage:</span>
<span class="sd">    &gt;&gt;&gt; name = &quot;John&quot;</span>
<span class="sd">    &gt;&gt;&gt; age = 30</span>
<span class="sd">    &gt;&gt;&gt; variable_name_as_string = get_variable_name(name)</span>
<span class="sd">    &gt;&gt;&gt; print(variable_name_as_string)</span>
<span class="sd">    &#39;name&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the calling frame</span>
    <span class="n">frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_back</span>

    <span class="c1"># Find the variable name by checking the locals and globals dictionaries</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_locals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">variable</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_globals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">variable</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span></div>


<div class="viewcode-block" id="generate_noisy_ellipse_points"><a class="viewcode-back" href="../functions.html#functions.generate_noisy_ellipse_points">[docs]</a><span class="k">def</span> <span class="nf">generate_noisy_ellipse_points</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">center_x</span><span class="p">,</span> <span class="n">center_y</span><span class="p">,</span> <span class="n">num_points</span><span class="p">,</span>
                                  <span class="n">std_dev</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate points along a noisy ellipse.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : float</span>
<span class="sd">        Semi-major axis of the ellipse.</span>
<span class="sd">    b : float</span>
<span class="sd">        Semi-minor axis of the ellipse.</span>
<span class="sd">    center_x : float</span>
<span class="sd">        x-coordinate of the center of the ellipse.</span>
<span class="sd">    center_y : float</span>
<span class="sd">        y-coordinate of the center of the ellipse.</span>
<span class="sd">    num_points : int</span>
<span class="sd">        Number of points to generate.</span>
<span class="sd">    std_dev : float</span>
<span class="sd">        Standard deviation for the noise added to the points.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : numpy.ndarray</span>
<span class="sd">        Array of x-coordinates of the generated points.</span>
<span class="sd">    y : numpy.ndarray</span>
<span class="sd">        Array of y-coordinates of the generated points.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    a = 3.0</span>
<span class="sd">    b = 1.5</span>
<span class="sd">    center_x = 2.0</span>
<span class="sd">    center_y = 1.0</span>
<span class="sd">    num_points = 100</span>
<span class="sd">    std_dev = 0.1</span>
<span class="sd">    x, y = generate_noisy_ellipse_points(a, b, center_x, center_y,</span>
<span class="sd">                                         num_points, std_dev)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Generate angles evenly spaced around the ellipse (0 to 2*pi)</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num_points</span><span class="p">)</span>

    <span class="c1"># Parametric equations of the ellipse</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">center_x</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">center_y</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>

    <span class="c1"># Add noise from a standard normal distribution</span>
    <span class="n">noise_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">std_dev</span><span class="p">,</span> <span class="n">num_points</span><span class="p">)</span>
    <span class="n">noise_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">std_dev</span><span class="p">,</span> <span class="n">num_points</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">+=</span> <span class="n">noise_x</span>
    <span class="n">y</span> <span class="o">+=</span> <span class="n">noise_y</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>


<div class="viewcode-block" id="generate_ellipse_points"><a class="viewcode-back" href="../functions.html#functions.generate_ellipse_points">[docs]</a><span class="k">def</span> <span class="nf">generate_ellipse_points</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">semi_major_axis</span><span class="p">,</span> <span class="n">semi_minor_axis</span><span class="p">,</span>
                            <span class="n">num_points</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate points along an ellipse.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    center : tuple of float</span>
<span class="sd">        Center coordinates of the ellipse (x, y).</span>
<span class="sd">    semi_major_axis : float</span>
<span class="sd">        Length of the semi-major axis.</span>
<span class="sd">    semi_minor_axis : float</span>
<span class="sd">        Length of the semi-minor axis.</span>
<span class="sd">    num_points : int</span>
<span class="sd">        Number of points to generate on the ellipse.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_points : numpy.ndarray</span>
<span class="sd">        Array of x-coordinates of generated points.</span>
<span class="sd">    y_points : numpy.ndarray</span>
<span class="sd">        Array of y-coordinates of generated points.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    Center = (3, 4)</span>
<span class="sd">    Semi_major_axis = 5</span>
<span class="sd">    Semi_minor_axis = 3</span>
<span class="sd">    Num_points = 100</span>
<span class="sd">    x_points, y_points = generate_ellipse_points(Center, Semi_major_axis,</span>
<span class="sd">                                                 Semi_minor_axis, Num_points)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num_points</span><span class="p">)</span>
    <span class="n">cos_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
    <span class="n">sin_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>

    <span class="n">x_points</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">semi_major_axis</span> <span class="o">*</span> <span class="n">cos_angles</span>
    <span class="n">y_points</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">semi_minor_axis</span> <span class="o">*</span> <span class="n">sin_angles</span>

    <span class="k">return</span> <span class="n">x_points</span><span class="p">,</span> <span class="n">y_points</span></div>


<div class="viewcode-block" id="read_data_from_file"><a class="viewcode-back" href="../functions.html#functions.read_data_from_file">[docs]</a><span class="k">def</span> <span class="nf">read_data_from_file</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read data from a file and return it as a dictionary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file_path : str</span>
<span class="sd">        The path to the file containing the data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary containing the parsed data with PointIDs as keys and</span>
<span class="sd">        associated values including azimuth, zenith angle, distance, Cartesian</span>
<span class="sd">        coordinates, and units.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If duplicate PointIDs are found in the data or an invalid data format</span>
<span class="sd">        is specified in the header.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    file_path = &quot;data.txt&quot;</span>
<span class="sd">    data_dict, file_path = read_data_from_file(file_path)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

        <span class="c1"># Get the data format from the header</span>
        <span class="n">data_format_line</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
        <span class="n">data_format</span> <span class="o">=</span> <span class="n">data_format_line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="c1"># Get the units from the header</span>
        <span class="n">units_line</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
        <span class="n">units</span> <span class="o">=</span> <span class="n">units_line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">data_format</span> <span class="o">==</span> <span class="s1">&#39;spherical&#39;</span><span class="p">:</span>
            <span class="n">angle_unit</span> <span class="o">=</span> <span class="n">units</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">d_unit</span> <span class="o">=</span> <span class="n">units</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">coordinate_unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">data_format</span> <span class="o">==</span> <span class="s1">&#39;cartesian&#39;</span><span class="p">:</span>
            <span class="n">angle_unit</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">d_unit</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">coordinate_unit</span> <span class="o">=</span> <span class="n">units</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">data_format</span> <span class="o">==</span> <span class="s1">&#39;cartesian2d&#39;</span><span class="p">:</span>  <span class="c1"># New format for 2D Cartesian data</span>
            <span class="n">angle_unit</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">d_unit</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">coordinate_unit</span> <span class="o">=</span> <span class="n">units</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid data format specified in the header.&quot;</span><span class="p">)</span>

        <span class="c1"># Process the data lines</span>
        <span class="n">line_number</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="n">line_number</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

                <span class="c1"># Skip empty lines</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">PointID</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">data_format</span> <span class="o">==</span> <span class="s1">&#39;spherical&#39;</span><span class="p">:</span>
                    <span class="n">azimuth</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">))</span>
                    <span class="n">zenith_angle</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">))</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">))</span>

                    <span class="c1"># Convert spherical to Cartesian</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">coordinate_unit</span> <span class="o">=</span> <span class="n">spherical_to_cartesian_unit</span><span class="p">(</span>
                        <span class="n">distance</span><span class="p">,</span> <span class="n">d_unit</span><span class="p">,</span> <span class="n">angle_unit</span><span class="p">,</span> <span class="n">azimuth</span><span class="p">,</span> <span class="n">zenith_angle</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">data_format</span> <span class="o">==</span> <span class="s1">&#39;cartesian&#39;</span> <span class="ow">or</span> \
                        <span class="n">data_format</span> <span class="o">==</span> <span class="s1">&#39;cartesian2d&#39;</span><span class="p">:</span>

                    <span class="n">x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">))</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">))</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                        <span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">))</span>  <span class="c1"># Z for Cartesian 3D, None for 2D</span>
                <span class="c1"># Check for duplicate PointIDs</span>
                <span class="k">if</span> <span class="n">PointID</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Duplicate PointID &#39;</span><span class="si">{</span><span class="n">PointID</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;found in line </span><span class="si">{</span><span class="n">line_number</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

                <span class="c1"># Store data in the dictionary</span>
                <span class="n">data_dict</span><span class="p">[</span><span class="n">PointID</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;Hz&#39;</span><span class="p">:</span> <span class="n">azimuth</span> <span class="k">if</span> <span class="n">data_format</span> <span class="o">==</span> <span class="s1">&#39;spherical&#39;</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="s1">&#39;V&#39;</span><span class="p">:</span> <span class="n">zenith_angle</span> <span class="k">if</span> <span class="n">data_format</span> <span class="o">==</span> <span class="s1">&#39;spherical&#39;</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">distance</span> <span class="k">if</span> <span class="n">data_format</span> <span class="o">==</span> <span class="s1">&#39;spherical&#39;</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span>
                    <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span>
                    <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="n">z</span><span class="p">,</span>
                    <span class="s1">&#39;angle_unit&#39;</span><span class="p">:</span> <span class="n">angle_unit</span> <span class="k">if</span> <span class="n">data_format</span> <span class="o">==</span> <span class="s1">&#39;spherical&#39;</span>
                    <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># belongs to previous line, just was too long</span>
                    <span class="s1">&#39;d_unit&#39;</span><span class="p">:</span> <span class="n">d_unit</span> <span class="k">if</span> <span class="n">data_format</span> <span class="o">==</span> <span class="s1">&#39;spherical&#39;</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="s1">&#39;coordinate_unit&#39;</span><span class="p">:</span> <span class="n">coordinate_unit</span><span class="p">,</span>
                <span class="p">}</span>

    <span class="k">return</span> <span class="n">data_dict</span><span class="p">,</span> <span class="n">file_path</span></div>


<div class="viewcode-block" id="distance_to_mm"><a class="viewcode-back" href="../functions.html#functions.distance_to_mm">[docs]</a><span class="k">def</span> <span class="nf">distance_to_mm</span><span class="p">(</span><span class="n">unit</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a coordinate unit to millimeters.</span>

<span class="sd">    Converts a coordinate unit to its equivalent value in millimeters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unit : str</span>
<span class="sd">        The coordinate unit to be converted. Should be one of &quot;um&quot;, &quot;mm&quot;, &quot;cm&quot;,</span>
<span class="sd">        or &quot;m&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The equivalent value of the coordinate unit in millimeters.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the input coordinate unit is not one of &quot;um&quot;, &quot;mm&quot;, &quot;cm&quot;, or &quot;m&quot;.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; distance_to_mm(&quot;mm&quot;)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance_to_mm(&quot;cm&quot;)</span>
<span class="sd">    10.0</span>
<span class="sd">    &gt;&gt;&gt; distance_to_mm(&quot;m&quot;)</span>
<span class="sd">    1000.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;um&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.001</span>
    <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;mm&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.0</span>
    <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;cm&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">10.0</span>
    <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1000.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid coordinate unit specified.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_angle_scale"><a class="viewcode-back" href="../functions.html#functions.get_angle_scale">[docs]</a><span class="k">def</span> <span class="nf">get_angle_scale</span><span class="p">(</span><span class="n">output_units</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the scaler to convert angles to rads based on the output_units.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    output_units : dict</span>
<span class="sd">        A dictionary containing units for different quantities.</span>
<span class="sd">        Example: {&quot;angles&quot;: &quot;deg&quot;} for degrees.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The scaling factor to convert angles to radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">output_units</span><span class="p">[</span><span class="s2">&quot;angles&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;gon&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">200.0</span>  <span class="c1"># Convert gon to radians</span>
    <span class="k">elif</span> <span class="n">output_units</span><span class="p">[</span><span class="s2">&quot;angles&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;rad&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.0</span>
    <span class="k">elif</span> <span class="n">output_units</span><span class="p">[</span><span class="s2">&quot;angles&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;mrad&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.001</span>
    <span class="k">elif</span> <span class="n">output_units</span><span class="p">[</span><span class="s2">&quot;angles&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;deg&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span>  <span class="c1"># Convert degrees to radians</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid angle unit &#39;</span><span class="si">{</span><span class="n">output_units</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;specified.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_angle_scale_unit"><a class="viewcode-back" href="../functions.html#functions.get_angle_scale_unit">[docs]</a><span class="k">def</span> <span class="nf">get_angle_scale_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;gon&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">200</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;rad&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.0</span>
    <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;mrad&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.001</span>
    <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;deg&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">180.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid angle unit specified in the header.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="make_residual_stats"><a class="viewcode-back" href="../functions.html#functions.make_residual_stats">[docs]</a><span class="k">def</span> <span class="nf">make_residual_stats</span><span class="p">(</span><span class="n">residuals</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate various statistical measures from a set of residuals.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    residuals : numpy.ndarray or list or tuple</span>
<span class="sd">        The residuals to compute statistics for.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary containing the following statistical measures:</span>
<span class="sd">        - &quot;Standard Deviation&quot;: Standard deviation of the residuals.</span>
<span class="sd">        - &quot;Maximum |Residual|&quot;: Maximum absolute value of the residuals.</span>
<span class="sd">        - &quot;Minimum |Residual|&quot;: Minimum absolute value of the residuals.</span>
<span class="sd">        - &quot;RMS&quot;: Root Mean Square (RMS) of the residuals.</span>
<span class="sd">        - &quot;Mean&quot;: Mean value of the residuals.</span>
<span class="sd">        - &quot;Median&quot;: Median value of the residuals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>

    <span class="n">statistics</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;Standard Deviation&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">residuals</span><span class="p">),</span>
        <span class="s2">&quot;Maximum |Residual|&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">residuals</span><span class="p">)),</span>
        <span class="s2">&quot;Minimum |Residual|&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">residuals</span><span class="p">)),</span>
        <span class="s2">&quot;RMS&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">residuals</span><span class="o">**</span><span class="mi">2</span><span class="p">)),</span>
        <span class="s2">&quot;Mean&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">residuals</span><span class="p">),</span>
        <span class="s2">&quot;Median&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">statistics</span></div>


<div class="viewcode-block" id="fit_circle_2d"><a class="viewcode-back" href="../functions.html#functions.fit_circle_2d">[docs]</a><span class="k">def</span> <span class="nf">fit_circle_2d</span><span class="p">(</span><span class="n">data_tuple</span><span class="p">,</span> <span class="n">output_units</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">log_statistics</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit a circle to 2D data points using least squares optimization.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_tuple : tuple</span>
<span class="sd">        A tuple containing a dictionary of data points and the file path</span>
<span class="sd">        associated with the data.</span>
<span class="sd">    output_units : dict</span>
<span class="sd">        A dictionary specifying the desired output units for the circle&#39;s</span>
<span class="sd">        parameters.</span>
<span class="sd">    log_file_path : str, optional</span>
<span class="sd">        Path to a log file for recording fit details (default is None).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict or None</span>
<span class="sd">        A dictionary containing information about the fitted circle if</span>
<span class="sd">        successful:</span>
<span class="sd">        - &quot;name&quot;: Name of the fitted circle.</span>
<span class="sd">        - &quot;center&quot;: Tuple containing (center_x, center_y) coordinates of the</span>
<span class="sd">        circle&#39;s center.</span>
<span class="sd">        - &quot;radius&quot;: Radius of the fitted circle.</span>
<span class="sd">        - &quot;statistics&quot;: Dictionary containing statistics about the radial</span>
<span class="sd">        offsets.</span>
<span class="sd">        - &quot;point_radial_offsets&quot;: Dictionary containing radial offsets for</span>
<span class="sd">        each data point.</span>
<span class="sd">        Returns None if the circle fitting fails.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This function fits a circle in 2D using least squares optimization. It</span>
<span class="sd">    extracts data from the input dictionary,</span>
<span class="sd">    fits a circle, scales the output based on the specified output units,</span>
<span class="sd">    calculates radial offsets,</span>
<span class="sd">    and provides various statistics about the fitting results.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data_dict</span><span class="p">,</span> <span class="n">file_path</span> <span class="o">=</span> <span class="n">data_tuple</span>
    <span class="n">circle_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">file_path</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Extract data from the dictionary</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="c1"># Create a list to store point names</span>
    <span class="n">point_names</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">point_name</span><span class="p">,</span> <span class="n">point_data</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Parse data in Cartesian format</span>
        <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">distance_to_mm</span><span class="p">(</span><span class="n">point_data</span><span class="p">[</span>
            <span class="s1">&#39;coordinate_unit&#39;</span><span class="p">]))</span>
        <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">distance_to_mm</span><span class="p">(</span><span class="n">point_data</span><span class="p">[</span>
            <span class="s1">&#39;coordinate_unit&#39;</span><span class="p">]))</span>

        <span class="c1"># Store the point name</span>
        <span class="n">point_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point_name</span><span class="p">)</span>

    <span class="c1"># Fit a circle in 2D using least squares optimization</span>
    <span class="n">initial_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">),</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                                              <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">))])</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">circle_residuals_2d</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

    <span class="c1"># Check if the optimization succeeded</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
        <span class="n">center_x</span><span class="p">,</span> <span class="n">center_y</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No circle could be fit to the data of </span><span class="si">{circle_name}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Scale the output based on output_units from config.py</span>
    <span class="n">result_scale</span> <span class="o">=</span> <span class="n">get_distance_scale</span><span class="p">(</span><span class="n">output_units</span><span class="p">)</span>

    <span class="c1"># Scale the output</span>
    <span class="n">center_x</span><span class="p">,</span> <span class="n">center_y</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">center_x</span> <span class="o">*</span> <span class="n">result_scale</span><span class="p">,</span> <span class="n">center_y</span> <span class="o">*</span> \
        <span class="n">result_scale</span><span class="p">,</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">result_scale</span>
        
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">result_scale</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">result_scale</span>

    <span class="c1"># Calculate radial offsets</span>
    <span class="n">radial_offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">center_x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">center_y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">radius</span>


    <span class="c1"># Create a dictionary to store radial offsets for each point</span>
    <span class="n">point_radial_offsets</span> <span class="o">=</span> <span class="p">{</span><span class="n">point_name</span><span class="p">:</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">point_name</span><span class="p">,</span>
                            <span class="n">offset</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">point_names</span><span class="p">,</span> <span class="n">radial_offsets</span><span class="p">)}</span>
    <span class="c1"># Prepare statistics if requested</span>
    <span class="n">statistics</span> <span class="o">=</span> <span class="n">make_residual_stats</span><span class="p">(</span><span class="n">radial_offsets</span><span class="p">)</span>
    <span class="n">result_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">circle_name</span><span class="p">,</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">center_x</span><span class="p">,</span>
                                                   <span class="n">center_y</span><span class="p">),</span>
                   <span class="s2">&quot;radius&quot;</span><span class="p">:</span> <span class="n">radius</span><span class="p">,</span> <span class="s2">&quot;circle_statistics&quot;</span><span class="p">:</span> <span class="n">statistics</span><span class="p">,</span>
                   <span class="s2">&quot;radial_offsets&quot;</span><span class="p">:</span> <span class="n">point_radial_offsets</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">log</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">log_statistics</span><span class="p">:</span>
        <span class="n">write_2D_circle_fit_log</span><span class="p">(</span><span class="n">result_dict</span><span class="p">,</span> <span class="n">output_units</span><span class="p">,</span> <span class="n">log</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">write_2D_circle_fit_log</span><span class="p">(</span><span class="n">result_dict</span><span class="p">,</span> <span class="n">output_units</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span>
                                <span class="n">log_statistics</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result_dict</span></div>


<div class="viewcode-block" id="circle_residuals_2d"><a class="viewcode-back" href="../functions.html#functions.circle_residuals_2d">[docs]</a><span class="k">def</span> <span class="nf">circle_residuals_2d</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the residuals for 2D circle fitting.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    params : numpy.ndarray</span>
<span class="sd">        Array containing the parameters of the circle: center_x, center_y, and</span>
<span class="sd">        radius.</span>
<span class="sd">    x : numpy.ndarray</span>
<span class="sd">        Array of x-coordinates of data points.</span>
<span class="sd">    y : numpy.ndarray</span>
<span class="sd">        Array of y-coordinates of data points.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Array of residuals representing the difference between the distances</span>
<span class="sd">        of data points from the circle&#39;s circumference and the circle&#39;s radius.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This function calculates the residuals for 2D circle fitting. It takes the</span>
<span class="sd">    center coordinates (center_x, center_y) and radius of the circle as</span>
<span class="sd">    parameters, along with arrays of x and y coordinates of data points. The</span>
<span class="sd">    residuals are the differences between the distances of data points from the</span>
<span class="sd">    circle&#39;s circumference and the circle&#39;s radius.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">center_x</span><span class="p">,</span> <span class="n">center_y</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">params</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">center_x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">center_y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">radius</span></div>


<div class="viewcode-block" id="get_distance_scale"><a class="viewcode-back" href="../functions.html#functions.get_distance_scale">[docs]</a><span class="k">def</span> <span class="nf">get_distance_scale</span><span class="p">(</span><span class="n">output_units</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the scaling factor for distance units.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    output_units : dict</span>
<span class="sd">        Dictionary containing the desired output units, including &#39;distances&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Scaling factor for converting distances from the specified</span>
<span class="sd">        output units to millimeters.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If an invalid distance unit is specified in the &#39;distances&#39;</span>
<span class="sd">        field of the output_units dictionary.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This function calculates and returns the scaling factor to convert</span>
<span class="sd">    distances from the specified output units to millimeters. The valid</span>
<span class="sd">    distance units are &quot;m&quot; (meters), &quot;cm&quot; (centimeters), &quot;mm&quot;</span>
<span class="sd">    (millimeters), and &quot;um&quot; (micrometers). If an invalid distance unit</span>
<span class="sd">    is specified, a ValueError is raised.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">output_units</span><span class="p">[</span><span class="s2">&quot;distances&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.001</span>
    <span class="k">elif</span> <span class="n">output_units</span><span class="p">[</span><span class="s2">&quot;distances&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;cm&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.01</span>
    <span class="k">elif</span> <span class="n">output_units</span><span class="p">[</span><span class="s2">&quot;distances&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;mm&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.0</span>
    <span class="k">elif</span> <span class="n">output_units</span><span class="p">[</span><span class="s2">&quot;distances&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;um&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1000.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid distance unit &#39;</span><span class="si">{</span><span class="n">output_units</span><span class="p">[</span><span class="s1">&#39;distances&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot; specified.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="fit_plane"><a class="viewcode-back" href="../functions.html#functions.fit_plane">[docs]</a><span class="k">def</span> <span class="nf">fit_plane</span><span class="p">(</span><span class="n">data_tuple</span><span class="p">,</span> <span class="n">output_units</span><span class="p">,</span> <span class="n">log_details</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">log_statistics</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit a plane through 3D data points and calculate residual offsets.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_tuple : tuple</span>
<span class="sd">        Tuple containing the data dictionary and the file path.</span>
<span class="sd">    output_units : dict</span>
<span class="sd">        Dictionary specifying the desired output units.</span>
<span class="sd">    log_statistics : str, optional</span>
<span class="sd">        Whether to log statistics, by default &#39;False&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        Tuple containing the plane parameters and a dictionary with</span>
<span class="sd">        plane offsets and statistics.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the input data does not contain sufficient 3D points for</span>
<span class="sd">        plane fitting.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This function fits a plane through 3D data points and calculates the</span>
<span class="sd">    residual offsets of each point from the fitted plane. The input data</span>
<span class="sd">    is expected to be in the form of a data dictionary containing &#39;X&#39;, &#39;Y&#39;,</span>
<span class="sd">    and &#39;Z&#39; coordinates. The function returns the plane parameters as</span>
<span class="sd">    (a, b, c, d) coefficients of the plane equation: ax + by + cz + d = 0.</span>
<span class="sd">    Additionally, it returns a dictionary containing point names as keys</span>
<span class="sd">    and their residual offsets from the fitted plane as values, along with</span>
<span class="sd">    statistics calculated from the residuals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data_dict</span><span class="p">,</span> <span class="n">file_path</span> <span class="o">=</span> <span class="n">data_tuple</span>
    <span class="n">plane_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">file_path</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Check if 3D points are available</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span> <span class="ow">in</span> <span class="n">point_data</span> <span class="k">for</span> <span class="n">point_data</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The input data are not in 3D, a </span><span class="si">{</span><span class="n">plane_name</span><span class="si">}</span><span class="s2"> plane &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;cannot be fit through those points.&quot;</span><span class="p">)</span>

    <span class="c1"># Extract 3D points from the dictionary</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">point_data</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="s1">&#39;X&#39;</span> <span class="ow">in</span> <span class="n">point_data</span> <span class="ow">and</span> <span class="s1">&#39;Y&#39;</span> <span class="ow">in</span> <span class="n">point_data</span> <span class="ow">and</span> <span class="s1">&#39;Z&#39;</span> <span class="ow">in</span> <span class="n">point_data</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">distance_to_mm</span><span class="p">(</span>
                <span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;coordinate_unit&#39;</span><span class="p">]))</span>
            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">distance_to_mm</span><span class="p">(</span>
                <span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;coordinate_unit&#39;</span><span class="p">]))</span>
            <span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">distance_to_mm</span><span class="p">(</span>
                <span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;coordinate_unit&#39;</span><span class="p">]))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Insufficient 3D points available to fit a plane in &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">plane_name</span><span class="si">}</span><span class="s2">. At least three 3D points (X, Y, Z) &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;are required for plane fitting.&quot;</span><span class="p">)</span>

    <span class="c1"># Calculate the centroid of the points</span>
    <span class="n">centroid_x</span><span class="p">,</span> <span class="n">centroid_y</span><span class="p">,</span> <span class="n">centroid_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

    <span class="c1"># Shift the points to the centroid</span>
    <span class="n">x_shifted</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">centroid_x</span>
    <span class="n">y_shifted</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">centroid_y</span>
    <span class="n">z_shifted</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">centroid_z</span>

    <span class="c1"># Stack the coordinates as a matrix</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">x_shifted</span><span class="p">,</span> <span class="n">y_shifted</span><span class="p">,</span> <span class="n">z_shifted</span><span class="p">))</span>

    <span class="c1"># Use Singular Value Decomposition (SVD) to fit the plane</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># The normal vector of the plane is the last column of V</span>

    <span class="c1"># Extract coefficients from the normal vector</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">normal</span>

    <span class="c1"># Calculate d coefficient</span>
    <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">centroid_x</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">centroid_y</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">centroid_z</span><span class="p">)</span>

    <span class="c1"># Calculate the angle of the plane with respect to coordinate axes</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">get_plane_angles</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">output_units</span><span class="p">)</span>

    <span class="c1"># Calculate residuals</span>
    <span class="n">plane_params</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">residual_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">point_name</span><span class="p">:</span> <span class="n">point_to_plane_distance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">plane_params</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">point_name</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span>
                             <span class="n">data_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
                     <span class="p">}</span>

    <span class="c1"># Prepare statistics if requested</span>
    <span class="n">statistics</span> <span class="o">=</span> <span class="n">make_residual_stats</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">residual_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>

    <span class="n">result_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;plane_parameters&#39;</span><span class="p">:</span> <span class="n">plane_params</span><span class="p">,</span>
                   <span class="s1">&#39;planar_offsets&#39;</span><span class="p">:</span> <span class="n">residual_dict</span><span class="p">,</span>
                   <span class="s1">&#39;plane_statistics&#39;</span><span class="p">:</span> <span class="n">statistics</span><span class="p">,</span>
                   <span class="s1">&#39;angles_from_axis&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;Rx&#39;</span><span class="p">:</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                        <span class="s1">&#39;Ry&#39;</span><span class="p">:</span> <span class="n">angles</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="s1">&#39;Rz&#39;</span><span class="p">:</span> <span class="n">angles</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                                        <span class="p">}</span>
                   <span class="p">}</span>

    <span class="k">if</span> <span class="n">log_details</span><span class="p">:</span>
        <span class="n">write_plane_fit_log</span><span class="p">(</span><span class="n">result_dict</span><span class="p">,</span> <span class="n">output_units</span><span class="p">,</span> <span class="n">log_details</span><span class="p">,</span> <span class="n">log_statistics</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result_dict</span></div>


<div class="viewcode-block" id="get_plane_angles"><a class="viewcode-back" href="../functions.html#functions.get_plane_angles">[docs]</a><span class="k">def</span> <span class="nf">get_plane_angles</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">,</span> <span class="n">output_units</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the angles of a plane&#39;s normal vector to CS&#39; axes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    normal_vector : np.ndarray</span>
<span class="sd">        Normal vector of the plane.</span>
<span class="sd">    output_units : dict</span>
<span class="sd">        Dictionary specifying the desired output units.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        Tuple containing the angles in radians or converted output units.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This function calculates the angles of a plane&#39;s normal vector</span>
<span class="sd">    with respect to the coordinate axes. The normal vector should be</span>
<span class="sd">    provided as a NumPy ndarray. The function returns a tuple containing</span>
<span class="sd">    the angles calculated for the X, Y, and Z axes. The angles are</span>
<span class="sd">    expressed in radians by default or can be converted to the desired</span>
<span class="sd">    output units specified in the `output_units` dictionary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">normal_vector</span> <span class="o">=</span> <span class="n">normal_vector</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">)</span>
    <span class="n">Rx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Ry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">Rz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="c1"># Convert angles to the desired output units</span>
    <span class="n">angle_scale</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">get_angle_scale</span><span class="p">(</span><span class="n">output_units</span><span class="p">)</span>
    <span class="n">Rx</span> <span class="o">*=</span> <span class="n">angle_scale</span>
    <span class="n">Ry</span> <span class="o">*=</span> <span class="n">angle_scale</span>
    <span class="n">Rz</span> <span class="o">*=</span> <span class="n">angle_scale</span>
    <span class="k">return</span> <span class="n">Rx</span><span class="p">,</span> <span class="n">Ry</span><span class="p">,</span> <span class="n">Rz</span></div>


<div class="viewcode-block" id="write_circle_fit_log"><a class="viewcode-back" href="../functions.html#functions.write_circle_fit_log">[docs]</a><span class="k">def</span> <span class="nf">write_circle_fit_log</span><span class="p">(</span><span class="n">log_file_path</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span>
                         <span class="n">output_units</span><span class="p">,</span> <span class="n">statistics</span><span class="p">,</span> <span class="n">log_statistics</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write fitting results and statistics of a circle fit to a log file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_file_path : str</span>
<span class="sd">        Path to the log file.</span>
<span class="sd">    file_path : str</span>
<span class="sd">        Path to the source file.</span>
<span class="sd">    data_dict : dict</span>
<span class="sd">        Dictionary containing the data points used for circle fitting.</span>
<span class="sd">    center : dict</span>
<span class="sd">        Dictionary containing the center coordinates of the fitted circle.</span>
<span class="sd">    radius : float</span>
<span class="sd">        Radius of the fitted circle.</span>
<span class="sd">    output_units : dict</span>
<span class="sd">        Dictionary specifying the units used for output.</span>
<span class="sd">    statistics : dict</span>
<span class="sd">        Dictionary containing statistics related to the circle fit.</span>
<span class="sd">    log_statistics : bool, optional</span>
<span class="sd">        Flag indicating whether to log the statistics, by default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        Returns True if the log file was successfully written.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This function writes the results of a circle fitting operation and</span>
<span class="sd">    associated statistics to a log file. It receives parameters including</span>
<span class="sd">    the path to the log file, the source file, data points, circle center,</span>
<span class="sd">    radius, units, and statistics. The function also accepts a flag to</span>
<span class="sd">    determine whether to log the statistics or not. The log file is</span>
<span class="sd">    formatted with date and time information, as well as fitting details</span>
<span class="sd">    and optional statistics if requested.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">log_file_path</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">log_file_path</span><span class="p">,</span> <span class="s1">&#39;a+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">log_file</span><span class="p">:</span>
        <span class="n">circle_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
        <span class="c1"># Write header with date and time of calculation</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Circle </span><span class="si">{}</span><span class="s2"> Fitting Results:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">circle_name</span><span class="p">))</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Calculation Date: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)))</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Source File: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">file_path</span><span class="p">))</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Units: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_units</span><span class="p">[</span><span class="s2">&quot;distances&quot;</span><span class="p">]))</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Write circle fitting results</span>
        <span class="k">if</span> <span class="s2">&quot;center_z&quot;</span> <span class="ow">in</span> <span class="n">center</span><span class="p">:</span>
            <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Center: </span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="s2">&quot;center_x&quot;</span><span class="p">],</span>
                                                       <span class="n">center</span><span class="p">[</span><span class="s2">&quot;center_y&quot;</span><span class="p">],</span>
                                                       <span class="n">center</span><span class="p">[</span><span class="s2">&quot;center_z&quot;</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Center: </span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="s2">&quot;center_x&quot;</span><span class="p">],</span>
                                                    <span class="n">center</span><span class="p">[</span><span class="s2">&quot;center_y&quot;</span><span class="p">]))</span>

        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Radius: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">radius</span><span class="p">))</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Write statistics if available and log_statistics is True</span>
        <span class="k">if</span> <span class="n">log_statistics</span><span class="p">:</span>
            <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Best-fit Statistics:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">statistics</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
            <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="check_plane_projection"><a class="viewcode-back" href="../functions.html#functions.check_plane_projection">[docs]</a><span class="k">def</span> <span class="nf">check_plane_projection</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">normal_vector</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if the points lie on fitted plane or need to be projected onto it.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : list of tuples</span>
<span class="sd">        List of (x, y, z) points to be checked.</span>
<span class="sd">    center : tuple</span>
<span class="sd">        Center of the fitted plane in (x, y, z) coordinates.</span>
<span class="sd">    normal_vector : tuple</span>
<span class="sd">        Normal vector of the fitted plane in (a, b, c) form.</span>
<span class="sd">    tolerance : float</span>
<span class="sd">        Maximum allowable residual to consider points lying on the plane.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        True if points lie on the plane, False if points need to be projected</span>
<span class="sd">        onto the plane.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This function checks whether a list of given points lies on the fitted</span>
<span class="sd">    plane, based on their residuals from the plane. The parameters include the</span>
<span class="sd">    points to be checked, the center and normal vector of the fitted plane, and</span>
<span class="sd">    a tolerance value for residuals. The function calculates the residuals of</span>
<span class="sd">    each point from the plane and checks if the maximum residual is within the</span>
<span class="sd">    specified tolerance. If the maximum residual is below the tolerance, the</span>
<span class="sd">    function returns True, indicating that the points lie on the plane.</span>
<span class="sd">    Otherwise, it returns False, indicating that the points need to be</span>
<span class="sd">    projected onto the plane.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate the residuals of the points from the fitted circle</span>
    <span class="n">residuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">center</span><span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">))</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">]</span>

    <span class="c1"># Check if the maximum residual is within the tolerance</span>
    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="point_to_plane_distance"><a class="viewcode-back" href="../functions.html#functions.point_to_plane_distance">[docs]</a><span class="k">def</span> <span class="nf">point_to_plane_distance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">plane_params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate perpendicular distance from a 3D point to a plane.</span>

<span class="sd">    Given (X, Y, Z) coords of a 3D point and plane coeffs (a, b, c, d), where</span>
<span class="sd">    a, b, c are plane&#39;s normal vector components, d is the plane offset,</span>
<span class="sd">    this function computes perpendicular distance from point to the plane.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float</span>
<span class="sd">        X-coordinate of the 3D point.</span>
<span class="sd">    y : float</span>
<span class="sd">        Y-coordinate of the 3D point.</span>
<span class="sd">    z : float</span>
<span class="sd">        Z-coordinate of the 3D point.</span>
<span class="sd">    plane_params : tuple</span>
<span class="sd">        Coefficients of the plane as (a, b, c, d).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">       Perpendicular distance from the point to the plane, with directionality.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">plane_params</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="n">denominator</span>
    <span class="k">return</span> <span class="n">distance</span></div>


<div class="viewcode-block" id="project_points_onto_plane"><a class="viewcode-back" href="../functions.html#functions.project_points_onto_plane">[docs]</a><span class="k">def</span> <span class="nf">project_points_onto_plane</span><span class="p">(</span><span class="n">points_dict</span><span class="p">,</span> <span class="n">plane_params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Project 3D points onto a plane.</span>

<span class="sd">    Given a dictionary of 3D points and fitted plane coefficients, this</span>
<span class="sd">    function projects each 3D point onto the plane, resulting in corresponding</span>
<span class="sd">    3D coordinates on the plane. It also computes perpendicular distances from</span>
<span class="sd">    each point to the plane and stores them as &#39;planar_offset&#39; in the output</span>
<span class="sd">    dictionary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points_dict : dict</span>
<span class="sd">        Dictionary containing point data with names as keys and (X, Y, Z)</span>
<span class="sd">        coordinates as values.</span>
<span class="sd">    plane_params : tuple</span>
<span class="sd">        Coefficients of the fitted plane as (a, b, c, d), where &#39;a&#39;, &#39;b&#39;, &#39;c&#39;</span>
<span class="sd">        are normal vector components, and &#39;d&#39; is the plane&#39;s offset.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Dictionary with projected points (names as keys, (X, Y, Z) coordinates</span>
<span class="sd">        as values) and &#39;planar_offset&#39; indicating perpendicular distance of</span>
<span class="sd">        each point from the fitted plane.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">plane_params</span>
    <span class="n">points_projected</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">point_name</span><span class="p">,</span> <span class="n">point_data</span> <span class="ow">in</span> <span class="n">points_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">distance_to_mm</span><span class="p">(</span><span class="n">point_data</span><span class="p">[</span>
            <span class="s1">&#39;coordinate_unit&#39;</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">distance_to_mm</span><span class="p">(</span><span class="n">point_data</span><span class="p">[</span>
            <span class="s1">&#39;coordinate_unit&#39;</span><span class="p">])</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">distance_to_mm</span><span class="p">(</span><span class="n">point_data</span><span class="p">[</span>
            <span class="s1">&#39;coordinate_unit&#39;</span><span class="p">])</span>

        <span class="c1"># Project the point onto the plane</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">point_to_plane_distance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">plane_params</span><span class="p">)</span>
        <span class="n">x_proj</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">distance</span> <span class="o">*</span> <span class="n">a</span>
        <span class="n">y_proj</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">distance</span> <span class="o">*</span> <span class="n">b</span>
        <span class="n">z_proj</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">distance</span> <span class="o">*</span> <span class="n">c</span>

        <span class="c1"># Convert back to original units and store in the points_projected dict</span>
        <span class="n">points_projected</span><span class="p">[</span><span class="n">point_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">x_proj</span><span class="p">,</span>
            <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">y_proj</span><span class="p">,</span>
            <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="n">z_proj</span><span class="p">,</span>
            <span class="s1">&#39;coordinate_unit&#39;</span><span class="p">:</span> <span class="s1">&#39;mm&#39;</span>
        <span class="p">}</span>

    <span class="k">return</span> <span class="n">points_projected</span></div>


<div class="viewcode-block" id="rotate_to_xy_plane"><a class="viewcode-back" href="../functions.html#functions.rotate_to_xy_plane">[docs]</a><span class="k">def</span> <span class="nf">rotate_to_xy_plane</span><span class="p">(</span><span class="n">points_dict</span><span class="p">,</span> <span class="n">plane_params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotate points and plane coefficients to align with the XY plane.</span>

<span class="sd">    Given a dictionary of 3D points and fitted plane coefficients, this</span>
<span class="sd">    function projects each 3D point onto the plane, aligning them with the XY</span>
<span class="sd">    plane. It calculates a rotation matrix to align the plane&#39;s normal vector</span>
<span class="sd">    with the Z-axis, applies the rotation to both the points and the plane</span>
<span class="sd">    coefficients, and computes the perpendicular distances from the rotated</span>
<span class="sd">    points to the plane. Results are stored as &#39;planar_offset&#39; in the output</span>
<span class="sd">    dictionary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points_dict : dict</span>
<span class="sd">        Dictionary containing point data with names as keys and (X, Y, Z)</span>
<span class="sd">        coordinates as values. Each point_data should also contain</span>
<span class="sd">        &#39;coordinate_unit&#39; key specifying the unit of coordinates.</span>
<span class="sd">    plane_params : tuple</span>
<span class="sd">        Coefficients of the fitted plane as (a, b, c, d), where &#39;a&#39;, &#39;b&#39;, &#39;c&#39;</span>
<span class="sd">        are normal vector components, and &#39;d&#39; is the plane&#39;s offset.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Dictionary with rotated points (names as keys, (X, Y, Z) coordinates</span>
<span class="sd">        as values) and &#39;planar_offset&#39; indicating perpendicular distance of</span>
<span class="sd">        each point from the rotated plane. Also returns the inverse rotation</span>
<span class="sd">        matrix R_inv.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">plane_params</span>

    <span class="c1"># Calculate the normal vector of the plane in the original CS</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>

    <span class="n">normal_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">/</span><span class="n">norm</span><span class="p">,</span> <span class="n">b</span><span class="o">/</span><span class="n">norm</span><span class="p">,</span> <span class="n">c</span><span class="o">/</span><span class="n">norm</span><span class="p">])</span>

    <span class="c1"># Calculate the rotation matrix to align the plane&#39;s normal vector</span>
    <span class="c1"># with the Z-axis</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">rotation_matrix_from_vectors</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">R_inv</span> <span class="o">=</span> <span class="n">rotation_matrix_from_vectors</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">normal_vector</span><span class="p">)</span>

    <span class="n">distance</span> <span class="o">=</span> <span class="n">point_to_plane_distance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">plane_params</span><span class="p">)</span>
    <span class="c1"># Project the points onto the plane</span>
    <span class="n">points_transformed</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">point_name</span><span class="p">,</span> <span class="n">point_data</span> <span class="ow">in</span> <span class="n">points_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">distance_to_mm</span><span class="p">(</span><span class="n">point_data</span><span class="p">[</span>
            <span class="s1">&#39;coordinate_unit&#39;</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">distance_to_mm</span><span class="p">(</span><span class="n">point_data</span><span class="p">[</span>
            <span class="s1">&#39;coordinate_unit&#39;</span><span class="p">])</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">distance_to_mm</span><span class="p">(</span><span class="n">point_data</span><span class="p">[</span>
            <span class="s1">&#39;coordinate_unit&#39;</span><span class="p">])</span>

        <span class="n">x_trans</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">distance</span> <span class="o">*</span> <span class="n">a</span>
        <span class="n">y_trans</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">distance</span> <span class="o">*</span> <span class="n">b</span>
        <span class="n">z_trans</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="n">distance</span> <span class="o">*</span> <span class="n">c</span>

        <span class="c1"># Rotate the projected point</span>
        <span class="n">point_transformed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_trans</span><span class="p">,</span> <span class="n">y_trans</span><span class="p">,</span> <span class="n">z_trans</span><span class="p">]))</span>

        <span class="c1"># Convert back to original units and store in the points_transformed</span>
        <span class="c1"># dictionary</span>
        <span class="n">points_transformed</span><span class="p">[</span><span class="n">point_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">point_transformed</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="n">point_transformed</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="n">point_transformed</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="s1">&#39;coordinate_unit&#39;</span><span class="p">:</span> <span class="s1">&#39;mm&#39;</span>
        <span class="p">}</span>

    <span class="k">return</span> <span class="n">points_transformed</span><span class="p">,</span> <span class="n">R_inv</span></div>


<div class="viewcode-block" id="reverse_from_XYplane_to_original"><a class="viewcode-back" href="../functions.html#functions.reverse_from_XYplane_to_original">[docs]</a><span class="k">def</span> <span class="nf">reverse_from_XYplane_to_original</span><span class="p">(</span><span class="n">point_rotated</span><span class="p">,</span> <span class="n">plane_params</span><span class="p">,</span> <span class="n">R_inv</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reverse the rotation from the XY plane back to the original 3D CS.</span>

<span class="sd">    Given a rotated 2D point, the coefficients of a fitted plane, and the</span>
<span class="sd">    inverse rotation matrix, this function converts the rotated 2D point back</span>
<span class="sd">    to the original 3D coordinate system. It undoes the previous rotation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    point_rotated : tuple</span>
<span class="sd">        Rotated 2D point in the form (X, Y).</span>
<span class="sd">    plane_params : tuple</span>
<span class="sd">        Coefficients of the fitted plane in the form (a, b, c, d), where &#39;a&#39;,</span>
<span class="sd">        &#39;b&#39;, &#39;c&#39; are normal vector components, and &#39;d&#39; is the offset of the</span>
<span class="sd">        plane.</span>
<span class="sd">    R_inv : np.ndarray</span>
<span class="sd">        Inverse rotation matrix used to reverse the rotation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        Original 3D point in the form (X, Y, Z), representing the coordinates</span>
<span class="sd">        in the original coordinate system before rotation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">plane_params</span>

    <span class="c1"># Convert 2D coordinates back to 3D</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">point_rotated</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">point_rotated</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span>

    <span class="n">distance</span> <span class="o">=</span> <span class="n">point_to_plane_distance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">plane_params</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; NOTE ON MATH</span>
<span class="sd">    Next time when you are confused, why do we substract the &quot;point</span>
<span class="sd">    distance&quot;, it is not using the point itself, it is using the D, which is</span>
<span class="sd">    basically a scalar of a vector from origin of the plane to the origin of</span>
<span class="sd">    the original coordinate system. When multiplied by a, b and c, it creates</span>
<span class="sd">    a vector in direction: plane -&gt; origin (that is why it is substracted).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">point_rotated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R_inv</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">]))</span>
    <span class="n">x_orig</span> <span class="o">=</span> <span class="n">point_rotated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">distance</span> <span class="o">*</span> <span class="n">a</span>
    <span class="n">y_orig</span> <span class="o">=</span> <span class="n">point_rotated</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">distance</span> <span class="o">*</span> <span class="n">b</span>
    <span class="n">z_orig</span> <span class="o">=</span> <span class="n">point_rotated</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">distance</span> <span class="o">*</span> <span class="n">c</span>

    <span class="n">point_original</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_orig</span><span class="p">,</span> <span class="n">y_orig</span><span class="p">,</span> <span class="n">z_orig</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">point_original</span></div>


<div class="viewcode-block" id="rotation_matrix_from_vectors"><a class="viewcode-back" href="../functions.html#functions.rotation_matrix_from_vectors">[docs]</a><span class="k">def</span> <span class="nf">rotation_matrix_from_vectors</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the rotation matrix that aligns one vector with another.</span>

<span class="sd">    Given two 3D vectors v1 and v2, this function calculates the rotation</span>
<span class="sd">    matrix that aligns v1 with v2 using Rodrigues&#39; rotation formula. The</span>
<span class="sd">    resulting matrix can be used to rotate points or vectors from the reference</span>
<span class="sd">    frame defined by v1 to the reference frame defined by v2.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v1 : numpy.ndarray</span>
<span class="sd">        Original 3D vector to be rotated.</span>
<span class="sd">    v2 : numpy.ndarray</span>
<span class="sd">        Target 3D vector that v1 should align with.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        3x3 rotation matrix that transforms v1 to align with v2.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The algorithm used in this function is based on Rodrigues&#39; rotation</span>
<span class="sd">    formula, as described in</span>
<span class="sd">    https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">v1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>  <span class="c1"># normalized first vector</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">v2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>  <span class="c1"># normalized second vector</span>

    <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>  <span class="c1"># axis of rotation is being established</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>  <span class="c1"># axis is being directionalized</span>

    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span>  <span class="c1"># angle between the two vectors</span>

    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">axis</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                  <span class="p">[</span><span class="n">axis</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                  <span class="p">[</span><span class="o">-</span><span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">]])</span>

    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">K</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="plot_points_2d"><a class="viewcode-back" href="../functions.html#functions.plot_points_2d">[docs]</a><span class="k">def</span> <span class="nf">plot_points_2d</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot givenpoints in 2D.</span>

<span class="sd">    Given a dictionary of 3D or 2D points, this function generates a 2D scatter</span>
<span class="sd">    plot of the points. The points&#39; X and Y coordinates are extracted from the</span>
<span class="sd">    dictionary, and each point is annotated with its name.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points_rotated : dict</span>
<span class="sd">        Dictionary containing points with names as keys and (X, Y, Z)</span>
<span class="sd">        coordinates as values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract X, Y, and point names from the dictionary</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">point_data</span> <span class="ow">in</span> <span class="n">points</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="p">[</span><span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">point_data</span> <span class="ow">in</span> <span class="n">points</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="n">point_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="c1"># Create a 2D plot</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>

    <span class="c1"># Annotate each point with its name</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">point_names</span><span class="p">):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s2">&quot;offset points&quot;</span><span class="p">,</span>
                     <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>

    <span class="c1"># Set axis labels and title</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Points in 2D&quot;</span><span class="p">)</span>

    <span class="c1"># Show the plot</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="point_distance"><a class="viewcode-back" href="../functions.html#functions.point_distance">[docs]</a><span class="k">def</span> <span class="nf">point_distance</span><span class="p">(</span><span class="n">point_data1</span><span class="p">,</span> <span class="n">point_data2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Euclidean distance between two points in 3D space.</span>

<span class="sd">    Given two dictionaries representing points with (X, Y, Z) coordinates, this</span>
<span class="sd">    function calculates the Euclidean distance between the points. If the</span>
<span class="sd">    points are in 2D space, the function calculates the distance in the XY</span>
<span class="sd">    plane. If the points have a Z-coordinate, the distance is calculated in 3D.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    point_data1 : dict</span>
<span class="sd">        Dictionary containing the first point&#39;s coordinates (X, Y, Z).</span>
<span class="sd">    point_data2 : dict</span>
<span class="sd">        Dictionary containing the second point&#39;s coordinates (X, Y, Z).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The Euclidean distance between the two points.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If the points are in 2D space (with missing Z-coordinates), the function</span>
<span class="sd">    calculates the distance in the XY plane. If both points have Z-coordinates,</span>
<span class="sd">    the distance is calculated in 3D space.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; point1 = {&#39;X&#39;: 1, &#39;Y&#39;: 2, &#39;Z&#39;: 3}</span>
<span class="sd">    &gt;&gt;&gt; point2 = {&#39;X&#39;: 4, &#39;Y&#39;: 5, &#39;Z&#39;: 6}</span>
<span class="sd">    &gt;&gt;&gt; distance = point_distance(point1, point2)</span>
<span class="sd">    &gt;&gt;&gt; print(distance)</span>
<span class="sd">    5.196152422706632</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span> <span class="o">=</span> <span class="n">point_data1</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">],</span> <span class="n">point_data1</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">],</span> <span class="n">point_data1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">)</span>
    <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span> <span class="o">=</span> <span class="n">point_data2</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">],</span> <span class="n">point_data2</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">],</span> <span class="n">point_data2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">z1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">z2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">z2</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="compare_distances"><a class="viewcode-back" href="../functions.html#functions.compare_distances">[docs]</a><span class="k">def</span> <span class="nf">compare_distances</span><span class="p">(</span><span class="n">dict1</span><span class="p">,</span> <span class="n">dict2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">num_pairs</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compare distances between point pairs and check for discrepancies.</span>

<span class="sd">    Given two dictionaries of 3D points, this function compares the distances</span>
<span class="sd">    between corresponding pairs of points. It calculates the discrepancies in</span>
<span class="sd">    distances between the points from both dictionaries, considering a</span>
<span class="sd">    specified tolerance. The function returns a dictionary of point pairs with</span>
<span class="sd">    discrepancies that exceed the tolerance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dict1 : dict</span>
<span class="sd">        Dictionary containing point data with names as keys and (X, Y, Z)</span>
<span class="sd">        coordinates as values.</span>
<span class="sd">    dict2 : dict</span>
<span class="sd">        Another dictionary with the same structure as &#39;dict1&#39; containing point</span>
<span class="sd">        data.</span>
<span class="sd">    tolerance : float</span>
<span class="sd">        Maximum allowable discrepancy between distances to consider as within</span>
<span class="sd">        tolerance.</span>
<span class="sd">    num_pairs : int or str, optional</span>
<span class="sd">        Number of point pairs to compare. If &#39;all&#39;, compare all possible pairs.</span>
<span class="sd">        Default is &#39;all&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool or dict</span>
<span class="sd">        If all tested point pairs are within the tolerance, returns True.</span>
<span class="sd">        Otherwise, returns a dictionary of point pairs and their discrepancies</span>
<span class="sd">        that exceed the specified tolerance.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The &#39;coordinate_unit&#39; key in the dictionaries specifies the unit of</span>
<span class="sd">      coordinates.</span>
<span class="sd">    - The function compares distances between corresponding points in both</span>
<span class="sd">      dictionaries.</span>
<span class="sd">    - Point pairs with discrepancies exceeding the tolerance are considered</span>
<span class="sd">      out of spec.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; point_data1 = {&#39;A&#39;: {&#39;X&#39;: 1, &#39;Y&#39;: 2, &#39;Z&#39;: 3}, &#39;B&#39;: {&#39;X&#39;: 4, &#39;Y&#39;: 5,</span>
<span class="sd">                                                            &#39;Z&#39;: 6}}</span>
<span class="sd">    &gt;&gt;&gt; point_data2 = {&#39;A&#39;: {&#39;X&#39;: 1, &#39;Y&#39;: 2, &#39;Z&#39;: 3}, &#39;B&#39;: {&#39;X&#39;: 4, &#39;Y&#39;: 5,</span>
<span class="sd">                                                            &#39;Z&#39;: 6.5}}</span>
<span class="sd">    &gt;&gt;&gt; tolerance = 0.1</span>
<span class="sd">    &gt;&gt;&gt; result = compare_distances(point_data1, point_data2, tolerance)</span>
<span class="sd">    &gt;&gt;&gt; if result is True:</span>
<span class="sd">    ...     print(&quot;All point pairs are within tolerance.&quot;)</span>
<span class="sd">    ... else:</span>
<span class="sd">    ...     print(&quot;Point pairs with discrepancies:&quot;)</span>
<span class="sd">    ...     for pair, discrepancy in result.items():</span>
<span class="sd">    ...         print(f&quot;{pair}: {discrepancy:.4f} mm&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">point_names_dict1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dict1</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">point_names_dict2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dict2</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="n">common_point_names</span> <span class="o">=</span> <span class="n">point_names_dict1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">point_names_dict2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">num_pairs</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
        <span class="n">point_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">common_point_names</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">num_pairs</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_pairs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_point_names</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span>
            <span class="n">common_point_names</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">point_pairs</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span>
            <span class="n">common_point_names</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">num_pairs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">total_possible_pairs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_point_names</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span>
            <span class="n">common_point_names</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">total_pairs_tested</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">point_pairs</span><span class="p">)</span>
        <span class="n">out_of_spec_pairs</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">discrepancies</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">point_name1</span><span class="p">,</span> <span class="n">point_name2</span> <span class="ow">in</span> <span class="n">point_pairs</span><span class="p">:</span>
        <span class="n">distance_dict1</span> <span class="o">=</span> <span class="n">point_distance</span><span class="p">(</span><span class="n">dict1</span><span class="p">[</span><span class="n">point_name1</span><span class="p">],</span> <span class="n">dict1</span><span class="p">[</span><span class="n">point_name2</span><span class="p">])</span>
        <span class="n">distance_dict2</span> <span class="o">=</span> <span class="n">point_distance</span><span class="p">(</span><span class="n">dict2</span><span class="p">[</span><span class="n">point_name1</span><span class="p">],</span> <span class="n">dict2</span><span class="p">[</span><span class="n">point_name2</span><span class="p">])</span>

        <span class="c1"># Convert to millimeters based on unit specs or assume mm if not there</span>
        <span class="n">unit_dict1</span> <span class="o">=</span> <span class="n">dict1</span><span class="p">[</span><span class="n">point_name1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;coordinate_unit&#39;</span><span class="p">,</span> <span class="s1">&#39;mm&#39;</span><span class="p">)</span>
        <span class="n">unit_dict2</span> <span class="o">=</span> <span class="n">dict2</span><span class="p">[</span><span class="n">point_name1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;coordinate_unit&#39;</span><span class="p">,</span> <span class="s1">&#39;mm&#39;</span><span class="p">)</span>

        <span class="n">distance_dict1</span> <span class="o">*=</span> <span class="n">distance_to_mm</span><span class="p">(</span><span class="n">unit_dict1</span><span class="p">)</span>
        <span class="n">distance_dict2</span> <span class="o">*=</span> <span class="n">distance_to_mm</span><span class="p">(</span><span class="n">unit_dict2</span><span class="p">)</span>

        <span class="n">discrepancy</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">distance_dict1</span> <span class="o">-</span> <span class="n">distance_dict2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">discrepancy</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="n">sorted_pair</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">point_name1</span><span class="p">,</span> <span class="n">point_name2</span><span class="p">]))</span>
            <span class="n">discrepancies</span><span class="p">[</span><span class="n">sorted_pair</span><span class="p">]</span> <span class="o">=</span> <span class="n">discrepancy</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> 
        <span class="n">out_of_spec_pairs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">discrepancies</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Testing </span><span class="si">{</span><span class="n">total_pairs_tested</span><span class="si">}</span><span class="s2"> point pairs out of &quot;</span>
              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">total_possible_pairs</span><span class="si">}</span><span class="s2"> possible pairs.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">out_of_spec_pairs</span><span class="si">}</span><span class="s2"> pairs out of spec.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">discrepancies</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;All tested point pairs are within the tolerance.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Maximum discrepancy is </span><span class="si">{</span><span class="nb">max</span><span class="p">(</span><span class="n">discrepancies</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="si">}</span><span class="s2">,&quot;</span>
              <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">minimum discrepancy is </span><span class="si">{</span><span class="nb">max</span><span class="p">(</span><span class="n">discrepancies</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">point_name1</span><span class="p">,</span> <span class="n">point_name2</span><span class="p">),</span> <span class="n">discrepancy</span> <span class="ow">in</span> <span class="n">discrepancies</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Point pair &#39;</span><span class="si">{</span><span class="n">point_name1</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">point_name2</span><span class="si">}</span><span class="s2">&#39; has a &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;discrepancy of </span><span class="si">{</span><span class="n">discrepancy</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dict2</span><span class="p">[</span><span class="n">point_name1</span><span class="p">][</span><span class="s1">&#39;coordinate_unit&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">discrepancies</span></div>


<div class="viewcode-block" id="plot_cartesian_3d"><a class="viewcode-back" href="../functions.html#functions.plot_cartesian_3d">[docs]</a><span class="k">def</span> <span class="nf">plot_cartesian_3d</span><span class="p">(</span><span class="n">points_dict</span><span class="p">,</span> <span class="n">plane_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot points in a 3D Cartesian CS with optional plane visualization.</span>

<span class="sd">    Given a dictionary of 3D points and optional plane coefficients, this</span>
<span class="sd">    function creates a 3D plot of the points in a Cartesian coordinate system.</span>
<span class="sd">    Points are scattered in 3D space, with their names annotated near each</span>
<span class="sd">    point. If plane coefficients are provided, the fitted plane is also</span>
<span class="sd">    visualized in the plot.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points_dict : dict</span>
<span class="sd">        Dictionary containing point data with names as keys and (X, Y, Z)</span>
<span class="sd">        coordinates as values.</span>
<span class="sd">    plane_params : tuple or None, optional</span>
<span class="sd">        Coefficients of the fitted plane in the form (a, b, c, d), where &#39;a&#39;,</span>
<span class="sd">        &#39;b&#39;, and &#39;c&#39; are the normal vector components, and &#39;d&#39; is the offset of</span>
<span class="sd">        the plane. If None, no plane visualization is added. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The &#39;coordinate_unit&#39; key in the dictionary specifies the unit of</span>
<span class="sd">      coordinates.</span>
<span class="sd">    - Points are scattered in 3D space, and their names are annotated near</span>
<span class="sd">      each point.</span>
<span class="sd">    - If &#39;plane_params&#39; is provided, the fitted plane is visualized as a</span>
<span class="sd">      surface in the plot.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; point_data = {&#39;A&#39;: {&#39;X&#39;: 1, &#39;Y&#39;: 2, &#39;Z&#39;: 3}, &#39;B&#39;: {&#39;X&#39;: 4, &#39;Y&#39;: 5,</span>
<span class="sd">                                                           &#39;Z&#39;: 6}}</span>
<span class="sd">    &gt;&gt;&gt; plot_cartesian_3d(point_data)</span>
<span class="sd">    &gt;&gt;&gt; plot_cartesian_3d(point_data, plane_params=(1, 2, 3, 0))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>

    <span class="c1"># Extract point coordinates for setting plot limits</span>
    <span class="n">x_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">point_info</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">point_info</span> <span class="ow">in</span> <span class="n">points_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="n">y_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">point_info</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">point_info</span> <span class="ow">in</span> <span class="n">points_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="n">z_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">point_info</span><span class="p">[</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">point_info</span> <span class="ow">in</span> <span class="n">points_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

    <span class="c1"># Calculate plot limits</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_coords</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_coords</span><span class="p">)</span>
    <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y_coords</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_coords</span><span class="p">)</span>
    <span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">z_coords</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">z_coords</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">point_name</span><span class="p">,</span> <span class="n">point_info</span> <span class="ow">in</span> <span class="n">points_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">point_info</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">point_info</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">point_info</span><span class="p">[</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">point_name</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plane_params</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">plane_params</span>
        <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
        <span class="n">zz</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">a</span> <span class="o">*</span> <span class="n">xx</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">yy</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="n">c</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">zz</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_zlim</span><span class="p">(</span><span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Use block=True to open in a separate window</span></div>


<div class="viewcode-block" id="plot_spherical_3d"><a class="viewcode-back" href="../functions.html#functions.plot_spherical_3d">[docs]</a><span class="k">def</span> <span class="nf">plot_spherical_3d</span><span class="p">(</span><span class="n">points_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot 3D points in a spherical coordinate system.</span>

<span class="sd">    Given a dictionary of 3D points defined in spherical coordinates (radius</span>
<span class="sd">    &#39;d&#39;, azimuthal angle &#39;Hz&#39;, and polar angle &#39;V&#39;), this function creates a</span>
<span class="sd">    3D plot of the points in a spherical coordinate system. Points are</span>
<span class="sd">    scattered in 3D space based on their spherical coordinates, and their names</span>
<span class="sd">    are annotated near each point.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points_dict : dict</span>
<span class="sd">        Dictionary containing point data with names as keys and spherical</span>
<span class="sd">        coordinates as values. Each point&#39;s data should include &#39;d&#39; (radius),</span>
<span class="sd">        &#39;Hz&#39; (azimuthal angle in degrees), and &#39;V&#39; (polar angle in degrees).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Points are scattered in 3D space based on their spherical coordinates</span>
<span class="sd">      (radius, azimuthal angle, and polar angle).</span>
<span class="sd">    - The &#39;d&#39; values represent the radial distance, &#39;Hz&#39; values represent the</span>
<span class="sd">      azimuthal angle in degrees, and &#39;V&#39; values represent the polar angle in</span>
<span class="sd">      degrees.</span>
<span class="sd">    - Points&#39; names are annotated near each point in the plot.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; point_data = {&#39;A&#39;: {&#39;d&#39;: 1, &#39;Hz&#39;: 45, &#39;V&#39;: 30},</span>
<span class="sd">                      &#39;B&#39;: {&#39;d&#39;: 2, &#39;Hz&#39;: 60, &#39;V&#39;: 60}}</span>
<span class="sd">    &gt;&gt;&gt; plot_spherical_3d(point_data)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">point_name</span><span class="p">,</span> <span class="n">point_info</span> <span class="ow">in</span> <span class="n">points_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">point_info</span><span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">]</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">point_info</span><span class="p">[</span><span class="s1">&#39;Hz&#39;</span><span class="p">])</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">point_info</span><span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">])</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">point_name</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Use block=True to open in separate window</span></div>


<div class="viewcode-block" id="merge_circle_offsets"><a class="viewcode-back" href="../functions.html#functions.merge_circle_offsets">[docs]</a><span class="k">def</span> <span class="nf">merge_circle_offsets</span><span class="p">(</span><span class="n">dict1</span><span class="p">,</span> <span class="n">dict2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge two dictionaries containing circle offsets into a single dictionary.</span>

<span class="sd">    Given two dictionaries containing circle offsets, one with &#39;planar_offset&#39;</span>
<span class="sd">    and the other with &#39;radial_offset&#39;, this function merges the two</span>
<span class="sd">    dictionaries into a single dictionary. The merged dictionary will have</span>
<span class="sd">    point names as keys, and for each point, it will include both</span>
<span class="sd">    &#39;planar_offset&#39; and &#39;radial_offset&#39; values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    {dict1_name} : dict</span>
<span class="sd">        Dictionary containing &#39;planar_offset&#39; values for circle points, with</span>
<span class="sd">        point names as keys.</span>
<span class="sd">    {dict2_name} : dict</span>
<span class="sd">        Dictionary containing &#39;radial_offset&#39; values for circle points, with</span>
<span class="sd">        point names as keys.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Merged dictionary containing point names as keys and a sub-dictionary</span>
<span class="sd">        with &#39;planar_offset&#39; and &#39;radial_offset&#39; values as values.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the dictionaries do not have the same set of point names.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function assumes that both dictionaries share common point names.</span>
<span class="sd">    - The merged dictionary will include a sub-dictionary for each common</span>
<span class="sd">      point name, with &#39;planar_offset&#39; and &#39;radial_offset&#39; values from</span>
<span class="sd">      {dict1_name} and {dict2_name}, respectively.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dict1_name</span> <span class="o">=</span> <span class="n">get_variable_name</span><span class="p">(</span><span class="n">dict1</span><span class="p">)</span>
    <span class="n">dict2_name</span> <span class="o">=</span> <span class="n">get_variable_name</span><span class="p">(</span><span class="n">dict2</span><span class="p">)</span>

    <span class="n">point_names_dict1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dict1</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">point_names_dict2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dict2</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="n">common_point_names</span> <span class="o">=</span> <span class="n">point_names_dict1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">point_names_dict2</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_point_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No common point names between </span><span class="si">{</span><span class="n">dict1_name</span><span class="si">}</span><span class="s2"> and&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dict2_name</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_point_names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">point_names_dict1</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">common_point_names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">point_names_dict2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Point names in </span><span class="si">{</span><span class="n">dict1_name</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">dict2_name</span><span class="si">}</span><span class="s2"> do&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot; not match.&quot;</span><span class="p">)</span>

    <span class="n">merged_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">point_name</span> <span class="ow">in</span> <span class="n">common_point_names</span><span class="p">:</span>
        <span class="n">merged_dict</span><span class="p">[</span><span class="n">point_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;planar_offset&#39;</span><span class="p">:</span> <span class="n">dict1</span><span class="p">[</span><span class="n">point_name</span><span class="p">],</span>
            <span class="s1">&#39;radial_offset&#39;</span><span class="p">:</span> <span class="n">dict2</span><span class="p">[</span><span class="n">point_name</span><span class="p">]</span>
        <span class="p">}</span>

    <span class="k">return</span> <span class="n">merged_dict</span></div>


<div class="viewcode-block" id="fit_circle_3D"><a class="viewcode-back" href="../functions.html#functions.fit_circle_3D">[docs]</a><span class="k">def</span> <span class="nf">fit_circle_3D</span><span class="p">(</span><span class="n">data_tuple</span><span class="p">,</span> <span class="n">output_unit</span><span class="p">,</span> <span class="n">point_transform_check_tolerance</span><span class="p">,</span>
                  <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">log_statistics</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit a 3D circle to a set of 3D points in space.</span>

<span class="sd">    Given a data tuple containing a dictionary of 3D points and the associated</span>
<span class="sd">    file path, this function performs a circle fitting process in 3D space. It</span>
<span class="sd">    begins by fitting a plane to the given points using the &#39;fit_plane&#39;</span>
<span class="sd">    function. The points are then projected onto this fitted plane, followed by</span>
<span class="sd">    a rotation transformation that aligns the plane with the XY plane. The</span>
<span class="sd">    distances between the original and transformed points are compared using</span>
<span class="sd">    the &#39;compare_distances&#39; function to check for any discrepancies after the</span>
<span class="sd">    transformation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_tuple (tuple): A tuple containing the dictionary of 3D points and the</span>
<span class="sd">                        associated file path.</span>
<span class="sd">    output_unit (dict): Dictionary specifying the output units for distances.</span>
<span class="sd">    point_transform_check_tolerance (float): Tolerance for checking differences</span>
<span class="sd">                                             in point-to-point distances after</span>
<span class="sd">                                             transformation.</span>
<span class="sd">    log_statistics (bool, optional): If True, log statistics will be generated</span>
<span class="sd">                                     and stored. Defaults to False.</span>
<span class="sd">    print_statistics (bool, optional): If True, statistics will be printed.</span>
<span class="sd">                                       Defaults to False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict: A dictionary containing the fitted circle parameters and associated</span>
<span class="sd">    information, including:</span>
<span class="sd">          - &#39;center&#39;: The 3D coordinates of the circle&#39;s center.</span>
<span class="sd">          - &#39;radius&#39;: The radius of the fitted circle.</span>
<span class="sd">          - &#39;circle_normal_vector&#39;: The normal vector of the fitted circle&#39;s</span>
<span class="sd">             plane.</span>
<span class="sd">          - &#39;circle_name&#39;: The name of the circle.</span>
<span class="sd">          - &#39;offsets&#39;: Dictionary containing planar and radial offsets.</span>
<span class="sd">          - &#39;plane_statistics&#39;: Statistics from the fitted plane.</span>
<span class="sd">          - &#39;plane_angles_parameters&#39;: Parameters related to angles of the</span>
<span class="sd">             fitted plane.</span>
<span class="sd">          - &#39;circle_statistics&#39;: Statistics from the fitted circle.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function performs circle fitting in the following steps:</span>
<span class="sd">        1. Fit a plane to the 3D points.</span>
<span class="sd">        2. Project points onto the fitted plane.</span>
<span class="sd">        3. Rotate the points to align with the XY plane.</span>
<span class="sd">        4. Check for differences in point-to-point distances before and after</span>
<span class="sd">            transformation.</span>
<span class="sd">        5. Fit a 2D circle to the rotated points.</span>
<span class="sd">    - The output dictionary contains various statistical information about the</span>
<span class="sd">        fitted plane and circle.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data_dict</span><span class="p">,</span> <span class="n">file_path</span> <span class="o">=</span> <span class="n">data_tuple</span>
    <span class="n">circle_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">file_path</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># see readin function&#39;s docstring.</span>
    <span class="n">plane_dict</span> <span class="o">=</span> <span class="n">fit_plane</span><span class="p">(</span><span class="n">data_tuple</span><span class="p">,</span> <span class="n">output_unit</span><span class="p">)</span>
    <span class="n">plane_params</span> <span class="o">=</span> <span class="n">plane_dict</span><span class="p">[</span><span class="s1">&#39;plane_parameters&#39;</span><span class="p">]</span>

    <span class="n">points_projected</span> <span class="o">=</span> <span class="n">project_points_onto_plane</span><span class="p">(</span><span class="n">data_dict</span><span class="p">,</span> <span class="n">plane_params</span><span class="p">)</span>
    <span class="n">points_transformed</span><span class="p">,</span> <span class="n">Rot_matrix</span> <span class="o">=</span> <span class="n">rotate_to_xy_plane</span><span class="p">(</span><span class="n">points_projected</span><span class="p">,</span>
                                                        <span class="n">plane_params</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">compare_distances</span><span class="p">(</span><span class="n">data_dict</span><span class="p">,</span> <span class="n">points_transformed</span><span class="p">,</span>
                             <span class="n">point_transform_check_tolerance</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;During the </span><span class="si">{</span><span class="n">circle_name</span><span class="si">}</span><span class="s2"> circle fitting process, there has &quot;</span>
              <span class="sa">f</span><span class="s2">&quot;been a difference inpoint-to-point distances between pre-&quot;</span>
              <span class="sa">f</span><span class="s2">&quot; and post-transformation of tested pairs that exceeded &quot;</span>
              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">point_transform_check_tolerance</span><span class="si">}</span><span class="s2">mm .</span><span class="se">\n</span><span class="s2">Please review&quot;</span>
              <span class="sa">f</span><span class="s2">&quot; the detailed statistics and take appropriate &quot;</span>
              <span class="sa">f</span><span class="s2">&quot;actions. The fit has been performed anyway&quot;</span><span class="p">)</span>
    <span class="n">circle_params_2d</span> <span class="o">=</span> <span class="n">fit_circle_2d</span><span class="p">((</span><span class="n">points_transformed</span><span class="p">,</span> <span class="n">file_path</span><span class="p">),</span>
                                     <span class="n">output_unit</span><span class="p">)</span>

    <span class="n">circle_center_vector</span> <span class="o">=</span> <span class="n">reverse_from_XYplane_to_original</span><span class="p">(</span>
                                                    <span class="n">circle_params_2d</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">],</span>
                                                    <span class="n">plane_params</span><span class="p">,</span> <span class="n">Rot_matrix</span><span class="p">)</span>

    <span class="n">out_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;center&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">circle_center_vector</span><span class="p">),</span>
                <span class="s1">&#39;radius&#39;</span><span class="p">:</span> <span class="n">circle_params_2d</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">],</span>
                <span class="s1">&#39;circle_normal_vector&#39;</span><span class="p">:</span> <span class="n">plane_params</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span>
                <span class="s1">&#39;circle_name&#39;</span><span class="p">:</span> <span class="n">circle_name</span><span class="p">,</span>
                <span class="s1">&#39;offsets&#39;</span><span class="p">:</span> <span class="n">merge_circle_offsets</span><span class="p">(</span>
                                    <span class="n">plane_dict</span><span class="p">[</span><span class="s1">&#39;planar_offsets&#39;</span><span class="p">],</span>
                                    <span class="n">circle_params_2d</span><span class="p">[</span><span class="s1">&#39;radial_offsets&#39;</span><span class="p">]),</span>
                <span class="s1">&#39;plane_statistics&#39;</span><span class="p">:</span> <span class="n">plane_dict</span><span class="p">[</span><span class="s1">&#39;plane_statistics&#39;</span><span class="p">],</span>
                <span class="s1">&#39;plane_angles_parameters&#39;</span><span class="p">:</span> <span class="n">plane_dict</span><span class="p">[</span>
                    <span class="s1">&#39;angles_from_axis&#39;</span><span class="p">],</span>
                <span class="s1">&#39;circle_statistics&#39;</span><span class="p">:</span> <span class="n">circle_params_2d</span><span class="p">[</span><span class="s1">&#39;circle_statistics&#39;</span><span class="p">]}</span>
    <span class="k">if</span> <span class="n">log</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">log_statistics</span><span class="p">:</span>
        <span class="n">write_3D_circle_fit_log</span><span class="p">(</span><span class="n">out_dict</span><span class="p">,</span> <span class="n">output_unit</span><span class="p">,</span> <span class="n">log</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">write_3D_circle_fit_log</span><span class="p">(</span><span class="n">out_dict</span><span class="p">,</span> <span class="n">output_unit</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">log_statistics</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out_dict</span></div>


<div class="viewcode-block" id="write_3D_circle_fit_log"><a class="viewcode-back" href="../functions.html#functions.write_3D_circle_fit_log">[docs]</a><span class="k">def</span> <span class="nf">write_3D_circle_fit_log</span><span class="p">(</span><span class="n">results_dict</span><span class="p">,</span> <span class="n">output_units</span><span class="p">,</span> <span class="n">log_details</span><span class="p">,</span>
                            <span class="n">log_statistics</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write fitting results and statistics of a 3D circle fit to a log file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_file_path : str</span>
<span class="sd">        Path to the log file.</span>
<span class="sd">    results_dict : dict</span>
<span class="sd">        Dictionary containing the results of the 3D circle fit. The dictionary</span>
<span class="sd">        should include various parameters and statistics related to the fit.</span>
<span class="sd">    log_statistics : bool, optional</span>
<span class="sd">        Flag indicating whether to log the statistics, by default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        Returns True if the log file was successfully written.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This function writes the results of a 3D circle fitting operation and</span>
<span class="sd">    associated statistics to a log file. It receives the path to the log file</span>
<span class="sd">    and a dictionary containing the results of the 3D circle fit. The </span>
<span class="sd">    dictionary should include parameters such as the circle&#39;s center, radius,</span>
<span class="sd">    normal vector, offsets, plane statistics, circle statistics, etc. The log</span>
<span class="sd">    file is formatted with date and time information, as well as fitting </span>
<span class="sd">    details and optional statistics if requested.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">log_details</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">log_path</span><span class="p">,</span> <span class="n">log_precision</span> <span class="o">=</span> <span class="n">log_details</span>
    <span class="n">decimal_places_distances</span><span class="p">,</span> <span class="n">decimal_places_angles</span> <span class="o">=</span> <span class="n">calculate_decimal_places</span><span class="p">(</span><span class="n">output_units</span><span class="p">,</span> <span class="n">log_precision</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">log_path</span><span class="p">,</span> <span class="s1">&#39;a+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">log_file</span><span class="p">:</span>
        <span class="n">circle_name</span> <span class="o">=</span> <span class="n">results_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;circle_name&#39;</span><span class="p">,</span> <span class="s1">&#39;Unknown Circle&#39;</span><span class="p">)</span>
        <span class="n">distances_unit</span> <span class="o">=</span> <span class="n">output_units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;distances&#39;</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">)</span>
        <span class="n">angles_unit</span> <span class="o">=</span> <span class="n">output_units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;angles&#39;</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">)</span>
        
        <span class="c1"># Write header with date and time of calculation</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">3D Circle Fitting Results:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Calculation Date: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)))</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Circle Name: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">circle_name</span><span class="p">))</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Units: Distances [</span><span class="si">{</span><span class="n">distances_unit</span><span class="si">}</span><span class="s2">], Angles [</span><span class="si">{</span><span class="n">angles_unit</span><span class="si">}</span><span class="s2">]</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Write circle fitting results with formatted numbers</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Center: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="n">decimal_places_distances</span><span class="si">}</span><span class="s2">f&quot;</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">results_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">))))</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Radius: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">format</span><span class="p">(</span><span class="n">results_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radius&#39;</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">),</span> 
                   <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="n">decimal_places_distances</span><span class="si">}</span><span class="s2">f&quot;</span><span class="p">)))</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Circle Normal Vector: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimal_places_distances</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span> 
               <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">results_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;circle_normal_vector&#39;</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">)])))</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Write statistics if available and log_statistics is True</span>
        <span class="k">if</span> <span class="n">log_statistics</span><span class="p">:</span>
            <span class="n">circle_statistics</span> <span class="o">=</span> <span class="n">results_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;circle_statistics&#39;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Circle Fit Statistics:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">circle_statistics</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                    <span class="n">value_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimal_places_distances</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">value_str</span> <span class="o">=</span> <span class="n">value</span>
                <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value_str</span><span class="p">))</span>
            <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Write offsets as a table</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">results_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;offsets&#39;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="k">if</span> <span class="n">offsets</span><span class="p">:</span>
                <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Offsets:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Point ID Planar Offset Radial Offset</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">point_id</span><span class="p">,</span> <span class="n">offset_dict</span> <span class="ow">in</span> <span class="n">offsets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">planar_offset</span> <span class="o">=</span> <span class="n">offset_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;planar_offset&#39;</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">)</span>
                    <span class="n">radial_offset</span> <span class="o">=</span> <span class="n">offset_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radial_offset&#39;</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">)</span>

                    <span class="c1"># Format and align the columns with specified decimal places</span>
                    <span class="n">planar_str</span> <span class="o">=</span> \
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">planar_offset</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimal_places_distances</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
                    <span class="n">radial_str</span> <span class="o">=</span> \
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">radial_offset</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimal_places_distances</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
                    <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">point_id</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">planar_str</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">radial_str</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="calculate_decimal_places"><a class="viewcode-back" href="../functions.html#functions.calculate_decimal_places">[docs]</a><span class="k">def</span> <span class="nf">calculate_decimal_places</span><span class="p">(</span><span class="n">output_units</span><span class="p">,</span> <span class="n">log_precision</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate decimal places based on output units and log precision.</span>

<span class="sd">    This function calculates the number of decimal places required for both</span>
<span class="sd">    distances and angles in the context of logging fitting results. It takes</span>
<span class="sd">    into account the output units and the specified log precision for distances</span>
<span class="sd">    and angles.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    output_units : dict</span>
<span class="sd">        Dictionary specifying the units used for output distances and angles.</span>
<span class="sd">    log_precision : dict</span>
<span class="sd">        Dictionary specifying the log precision for distances and angles.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        A tuple containing two integers representing the number of decimal</span>
<span class="sd">        places needed for distances and angles in the log.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function performs the following steps:</span>
<span class="sd">      1. Scales the log precision to millimeters (mm).</span>
<span class="sd">      2. Scales the log precision in millimeters to the units of the</span>
<span class="sd">         output_units.</span>
<span class="sd">      3. Determines the number of decimal places required for distances based</span>
<span class="sd">         on the scaled log precision.</span>
<span class="sd">      4. Scales the log precision for angles to radians.</span>
<span class="sd">      5. Scales the log precision in radians to the units of the output_units.</span>
<span class="sd">      6. Determines the number of decimal places required for angles based on</span>
<span class="sd">         the scaled log precision.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">distances_precision</span><span class="p">,</span> <span class="n">distances_precision_unit</span> <span class="o">=</span> <span class="n">log_precision</span><span class="p">[</span><span class="s1">&#39;distances&#39;</span><span class="p">]</span>
    <span class="n">angles_precision</span><span class="p">,</span> <span class="n">angles_precision_unit</span> <span class="o">=</span> <span class="n">log_precision</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">]</span>

    <span class="c1"># Scale log_precision to mm</span>
    <span class="k">if</span> <span class="n">distances_precision_unit</span> <span class="o">!=</span> <span class="s1">&#39;mm&#39;</span><span class="p">:</span>
        <span class="n">log_precision_scaled_mm</span> <span class="o">=</span> <span class="n">distances_precision</span> <span class="o">*</span> <span class="n">distance_to_mm</span><span class="p">(</span>
            <span class="n">distances_precision_unit</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">log_precision_scaled_mm</span> <span class="o">=</span> <span class="n">distances_precision</span>
    <span class="c1"># print(&#39;Distance precision log:&#39;)</span>
    <span class="c1"># print(distances_precision, distances_precision_unit)</span>
    <span class="c1"># print(&#39;Distance precision Output&#39;)</span>
    <span class="c1"># print(output_units[&#39;distances&#39;])</span>
    <span class="c1"># print(f&#39;log_precision_scaled_mm:{log_precision_scaled_mm}&#39;)</span>

    <span class="c1"># Scale log_precision in mm to the units of output_units</span>
    <span class="k">if</span> <span class="n">output_units</span><span class="p">[</span><span class="s1">&#39;distances&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;mm&#39;</span><span class="p">:</span>
        <span class="n">log_precision_scaled_output</span> <span class="o">=</span> <span class="n">log_precision_scaled_mm</span> <span class="o">/</span> <span class="n">distance_to_mm</span><span class="p">(</span>
            <span class="n">output_units</span><span class="p">[</span><span class="s1">&#39;distances&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">log_precision_scaled_output</span> <span class="o">=</span> <span class="n">log_precision_scaled_mm</span>

    <span class="c1"># print(f&#39;log_precision_scaled_output:{log_precision_scaled_output}&#39;)</span>

    <span class="c1"># Determine the number of decimal places for distances</span>
    <span class="n">decimal_places_distances</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span>
        <span class="n">log_precision_scaled_output</span><span class="p">))),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># print(f&#39;decimal_places_distances:{decimal_places_distances}&#39;)</span>

    <span class="c1"># Scale log_precision for angles to radians</span>
    <span class="k">if</span> <span class="n">angles_precision_unit</span> <span class="o">!=</span> <span class="s1">&#39;rad&#39;</span><span class="p">:</span>
        <span class="n">log_precision_scaled_rad</span> <span class="o">=</span> <span class="n">angles_precision</span> <span class="o">*</span> <span class="n">get_angle_scale_unit</span><span class="p">(</span>
            <span class="n">angles_precision_unit</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">log_precision_scaled_rad</span> <span class="o">=</span> <span class="n">angles_precision</span>

    <span class="c1"># Scale log_precision in radians to the units of output_units</span>
    <span class="k">if</span> <span class="n">output_units</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;rad&#39;</span><span class="p">:</span>
        <span class="n">log_precision_scaled_output_angles</span> <span class="o">=</span> <span class="n">log_precision_scaled_rad</span> <span class="o">*</span> \
            <span class="n">get_angle_scale</span><span class="p">(</span><span class="n">output_units</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">log_precision_scaled_output_angles</span> <span class="o">=</span> <span class="n">log_precision_scaled_rad</span>
    <span class="c1"># Determine the number of decimal places for angles</span>
    <span class="n">decimal_places_angles</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">log_precision_scaled_output_angles</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">decimal_places_distances</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">decimal_places_angles</span><span class="o">+</span><span class="mi">1</span></div>


<div class="viewcode-block" id="write_2D_circle_fit_log"><a class="viewcode-back" href="../functions.html#functions.write_2D_circle_fit_log">[docs]</a><span class="k">def</span> <span class="nf">write_2D_circle_fit_log</span><span class="p">(</span><span class="n">results_dict</span><span class="p">,</span> <span class="n">output_units</span><span class="p">,</span>
                            <span class="n">log_details</span><span class="p">,</span> <span class="n">log_statistics</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write fitting results and statistics of a 2D circle fit to a log file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    results_dict : dict</span>
<span class="sd">        Dictionary containing the results of the 2D circle fit. The dictionary</span>
<span class="sd">        should include various parameters and statistics related to the fit.</span>
<span class="sd">    output_units : dict</span>
<span class="sd">        Dictionary specifying the units to use for distances and angles.</span>
<span class="sd">    log_details : tuple</span>
<span class="sd">        A tuple containing the log file path and log precision settings.</span>
<span class="sd">    log_statistics : bool, optional</span>
<span class="sd">        Flag indicating whether to log the statistics, by default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        Returns True if the log file was successfully written.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This function writes the results of a 2D circle fitting operation and</span>
<span class="sd">    associated statistics to a log file. It receives the path to the log file</span>
<span class="sd">    and a dictionary containing the results of the 2D circle fit. The</span>
<span class="sd">    dictionary should include parameters such as the circle&#39;s center, radius,</span>
<span class="sd">    and circle statistics. The log file is formatted with date and time</span>
<span class="sd">    information, as well as fitting details and optional statistics if</span>
<span class="sd">    requested.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">log_details</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">log_path</span><span class="p">,</span> <span class="n">log_precision</span> <span class="o">=</span> <span class="n">log_details</span>
    <span class="n">decimal_places_distances</span><span class="p">,</span> <span class="n">decimal_places_angles</span> <span class="o">=</span> <span class="n">calculate_decimal_places</span><span class="p">(</span>
        <span class="n">output_units</span><span class="p">,</span> <span class="n">log_precision</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">log_path</span><span class="p">,</span> <span class="s1">&#39;a+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">log_file</span><span class="p">:</span>
        <span class="n">circle_name</span> <span class="o">=</span> <span class="n">results_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;Unknown Circle&#39;</span><span class="p">)</span>
        <span class="n">distances_unit</span> <span class="o">=</span> <span class="n">output_units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;distances&#39;</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">)</span>
        <span class="n">angles_unit</span> <span class="o">=</span> <span class="n">output_units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;angles&#39;</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">)</span>

        <span class="c1"># Write header with date and time of calculation</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">2D Circle Fitting Results:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Calculation Date: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)))</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Circle Name: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">circle_name</span><span class="p">))</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Units: Distances [</span><span class="si">{</span><span class="n">distances_unit</span><span class="si">}</span><span class="s2">], &quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;Angles [</span><span class="si">{</span><span class="n">angles_unit</span><span class="si">}</span><span class="s2">]</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Write circle fitting results with formatted numbers</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Center: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="n">decimal_places_distances</span><span class="si">}</span><span class="s2">f&quot;</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">results_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;N/A&#39;</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">)))))</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Radius: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">format</span><span class="p">(</span><span class="n">results_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radius&#39;</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">),</span>
                   <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="n">decimal_places_distances</span><span class="si">}</span><span class="s2">f&quot;</span><span class="p">)))</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">log_statistics</span><span class="p">:</span>
            <span class="n">circle_statistics</span> <span class="o">=</span> <span class="n">results_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;circle_statistics&#39;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Circle Fit Statistics:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">circle_statistics</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                    <span class="n">value_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimal_places_distances</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">value_str</span> <span class="o">=</span> <span class="n">value</span>
                <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value_str</span><span class="p">))</span>
            <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Write offsets as a table</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">results_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radial_offsets&#39;</span><span class="p">,</span> <span class="p">{})</span>

            <span class="c1"># Write offsets as a table</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">results_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radial_offsets&#39;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="k">if</span> <span class="n">offsets</span><span class="p">:</span>
                <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Offsets:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Point ID Radial Offset</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">point_id</span><span class="p">,</span> <span class="n">radial_offset</span> <span class="ow">in</span> <span class="n">offsets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">radial_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">radial_offset</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimal_places_distances</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
                    <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">point_id</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">radial_str</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># Indicates successful writing</span></div>


<div class="viewcode-block" id="write_plane_fit_log"><a class="viewcode-back" href="../functions.html#functions.write_plane_fit_log">[docs]</a><span class="k">def</span> <span class="nf">write_plane_fit_log</span><span class="p">(</span><span class="n">result_dict</span><span class="p">,</span> <span class="n">output_units</span><span class="p">,</span>
                        <span class="n">log_details</span><span class="p">,</span> <span class="n">log_statistics</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write fitting results and statistics of a plane fit to a log file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    result_dict : dict</span>
<span class="sd">        Dictionary containing the results of the plane fit. The dictionary</span>
<span class="sd">        should include various parameters and statistics related to the fit.</span>
<span class="sd">    log_details : tuple</span>
<span class="sd">        A tuple containing the log file path and log precision settings.</span>
<span class="sd">    log_statistics : bool, optional</span>
<span class="sd">        Flag indicating whether to log the statistics, by default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        Returns True if the log file was successfully written.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This function writes the results of a plane fitting operation and associated</span>
<span class="sd">    statistics to a log file. It receives the path to the log file and a</span>
<span class="sd">    dictionary containing the results of the plane fit. The dictionary should</span>
<span class="sd">    include parameters such as the plane&#39;s parameters, planar offsets, plane</span>
<span class="sd">    statistics, and angles from the axis. The log file is formatted with date</span>
<span class="sd">    and time information, as well as fitting details and optional statistics if</span>
<span class="sd">    requested.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">log_details</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">log_path</span><span class="p">,</span> <span class="n">log_precision</span> <span class="o">=</span> <span class="n">log_details</span>
    <span class="n">decimal_places_distances</span><span class="p">,</span> <span class="n">decimal_places_angles</span> <span class="o">=</span> <span class="n">calculate_decimal_places</span><span class="p">(</span>
        <span class="n">output_units</span><span class="p">,</span> <span class="n">log_precision</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">log_path</span><span class="p">,</span> <span class="s1">&#39;a+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">log_file</span><span class="p">:</span>
        <span class="c1"># Write header with date and time of calculation</span>
        <span class="n">distances_unit</span> <span class="o">=</span> <span class="n">output_units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;distances&#39;</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">)</span>
        <span class="n">angles_unit</span> <span class="o">=</span> <span class="n">output_units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;angles&#39;</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">)</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Plane Fitting Results:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Calculation Date: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)))</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Units: Distances [</span><span class="si">{</span><span class="n">distances_unit</span><span class="si">}</span><span class="s2">], Angles [</span><span class="si">{</span><span class="n">angles_unit</span><span class="si">}</span><span class="s2">]</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Write plane parameters</span>
        <span class="n">plane_params</span> <span class="o">=</span> <span class="n">result_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;plane_parameters&#39;</span><span class="p">,</span>
                                       <span class="p">(</span><span class="s1">&#39;N/A&#39;</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">,</span> <span class="s1">&#39;N/A&#39;</span><span class="p">))</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Plane Parameters: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="n">decimal_places_distances</span><span class="si">}</span><span class="s2">f&quot;</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">plane_params</span><span class="p">)))</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Write angles from the axis</span>
        <span class="n">angles_from_axis</span> <span class="o">=</span> <span class="n">result_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;angles_from_axis&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Angles from Axis:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">angles_from_axis</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">angle_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimal_places_angles</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">angle_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">angle_str</span><span class="p">))</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">log_statistics</span><span class="p">:</span>
            <span class="n">plane_statistics</span> <span class="o">=</span> <span class="n">result_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;plane_statistics&#39;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Plane Fit Statistics:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">plane_statistics</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                    <span class="n">value_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimal_places_distances</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">value_str</span> <span class="o">=</span> <span class="n">value</span>
                <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value_str</span><span class="p">))</span>
            <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Write planar offsets as a table</span>
            <span class="n">planar_offsets</span> <span class="o">=</span> <span class="n">result_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;planar_offsets&#39;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="k">if</span> <span class="n">planar_offsets</span><span class="p">:</span>
                <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Planar Offsets:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Point ID Planar Offset</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">point_id</span><span class="p">,</span> <span class="n">planar_offset</span> <span class="ow">in</span> <span class="n">planar_offsets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">planar_str</span> <span class="o">=</span> \
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">planar_offset</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">decimal_places_distances</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span>\
                        <span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
                    <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">point_id</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">planar_str</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># Indicates successful writing</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Magnet Referencing Calculations Documentation</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Jana Barker.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>